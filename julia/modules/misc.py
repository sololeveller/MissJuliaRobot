#                         GNU AFFERO GENERAL PUBLIC LICENSE
#                            Version 3, 19 November 2007
#
#      Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#      Everyone is permitted to copy and distribute verbatim copies
#      of this license document, but changing it is not allowed.
#
#                                 Preamble
#
#       The GNU Affero General Public License is a free, copyleft license for
#     software and other kinds of works, specifically designed to ensure
#     cooperation with the community in the case of network server software.
#
#       The licenses for most software and other practical works are designed
#     to take away your freedom to share and change the works.  By contrast,
#     our General Public Licenses are intended to guarantee your freedom to
#     share and change all versions of a program--to make sure it remains free
#     software for all its users.
#
#       When we speak of free software, we are referring to freedom, not
#     price.  Our General Public Licenses are designed to make sure that you
#     have the freedom to distribute copies of free software (and charge for
#     them if you wish), that you receive source code or can get it if you
#     want it, that you can change the software or use pieces of it in new
#     free programs, and that you know you can do these things.
#
#       Developers that use our General Public Licenses protect your rights
#     with two steps: (1) assert copyright on the software, and (2) offer
#     you this License which gives you legal permission to copy, distribute
#     and/or modify the software.
#
#       A secondary benefit of defending all users' freedom is that
#     improvements made in alternate versions of the program, if they
#     receive widespread use, become available for other developers to
#     incorporate.  Many developers of free software are heartened and
#     encouraged by the resulting cooperation.  However, in the case of
#     software used on network servers, this result may fail to come about.
#     The GNU General Public License permits making a modified version and
#     letting the public access it on a server without ever releasing its
#     source code to the public.
#
#       The GNU Affero General Public License is designed specifically to
#     ensure that, in such cases, the modified source code becomes available
#     to the community.  It requires the operator of a network server to
#     provide the source code of the modified version running there to the
#     users of that server.  Therefore, public use of a modified version, on
#     a publicly accessible server, gives the public access to the source
#     code of the modified version.
#
#       An older license, called the Affero General Public License and
#     published by Affero, was designed to accomplish similar goals.  This is
#     a different license, not a version of the Affero GPL, but Affero has
#     released a new version of the Affero GPL which permits relicensing under
#     this license.
#
#       The precise terms and conditions for copying, distribution and
#     modification follow.
#
#                            TERMS AND CONDITIONS
#
#       0. Definitions.
#
#       "This License" refers to version 3 of the GNU Affero General Public License.
#
#       "Copyright" also means copyright-like laws that apply to other kinds of
#     works, such as semiconductor masks.
#
#       "The Program" refers to any copyrightable work licensed under this
#     License.  Each licensee is addressed as "you".  "Licensees" and
#     "recipients" may be individuals or organizations.
#
#       To "modify" a work means to copy from or adapt all or part of the work
#     in a fashion requiring copyright permission, other than the making of an
#     exact copy.  The resulting work is called a "modified version" of the
#     earlier work or a work "based on" the earlier work.
#
#       A "covered work" means either the unmodified Program or a work based
#     on the Program.
#
#       To "propagate" a work means to do anything with it that, without
#     permission, would make you directly or secondarily liable for
#     infringement under applicable copyright law, except executing it on a
#     computer or modifying a private copy.  Propagation includes copying,
#     distribution (with or without modification), making available to the
#     public, and in some countries other activities as well.
#
#       To "convey" a work means any kind of propagation that enables other
#     parties to make or receive copies.  Mere interaction with a user through
#     a computer network, with no transfer of a copy, is not conveying.
#
#       An interactive user interface displays "Appropriate Legal Notices"
#     to the extent that it includes a convenient and prominently visible
#     feature that (1) displays an appropriate copyright notice, and (2)
#     tells the user that there is no warranty for the work (except to the
#     extent that warranties are provided), that licensees may convey the
#     work under this License, and how to view a copy of this License.  If
#     the interface presents a list of user commands or options, such as a
#     menu, a prominent item in the list meets this criterion.
#
#       1. Source Code.
#
#       The "source code" for a work means the preferred form of the work
#     for making modifications to it.  "Object code" means any non-source
#     form of a work.
#
#       A "Standard Interface" means an interface that either is an official
#     standard defined by a recognized standards body, or, in the case of
#     interfaces specified for a particular programming language, one that
#     is widely used among developers working in that language.
#
#       The "System Libraries" of an executable work include anything, other
#     than the work as a whole, that (a) is included in the normal form of
#     packaging a Major Component, but which is not part of that Major
#     Component, and (b) serves only to enable use of the work with that
#     Major Component, or to implement a Standard Interface for which an
#     implementation is available to the public in source code form.  A
#     "Major Component", in this context, means a major essential component
#     (kernel, window system, and so on) of the specific operating system
#     (if any) on which the executable work runs, or a compiler used to
#     produce the work, or an object code interpreter used to run it.
#
#       The "Corresponding Source" for a work in object code form means all
#     the source code needed to generate, install, and (for an executable
#     work) run the object code and to modify the work, including scripts to
#     control those activities.  However, it does not include the work's
#     System Libraries, or general-purpose tools or generally available free
#     programs which are used unmodified in performing those activities but
#     which are not part of the work.  For example, Corresponding Source
#     includes interface definition files associated with source files for
#     the work, and the source code for shared libraries and dynamically
#     linked subprograms that the work is specifically designed to require,
#     such as by intimate data communication or control flow between those
#     subprograms and other parts of the work.
#
#       The Corresponding Source need not include anything that users
#     can regenerate automatically from other parts of the Corresponding
#     Source.
#
#       The Corresponding Source for a work in source code form is that
#     same work.
#
#       2. Basic Permissions.
#
#       All rights granted under this License are granted for the term of
#     copyright on the Program, and are irrevocable provided the stated
#     conditions are met.  This License explicitly affirms your unlimited
#     permission to run the unmodified Program.  The output from running a
#     covered work is covered by this License only if the output, given its
#     content, constitutes a covered work.  This License acknowledges your
#     rights of fair use or other equivalent, as provided by copyright law.
#
#       You may make, run and propagate covered works that you do not
#     convey, without conditions so long as your license otherwise remains
#     in force.  You may convey covered works to others for the sole purpose
#     of having them make modifications exclusively for you, or provide you
#     with facilities for running those works, provided that you comply with
#     the terms of this License in conveying all material for which you do
#     not control copyright.  Those thus making or running the covered works
#     for you must do so exclusively on your behalf, under your direction
#     and control, on terms that prohibit them from making any copies of
#     your copyrighted material outside their relationship with you.
#
#       Conveying under any other circumstances is permitted solely under
#     the conditions stated below.  Sublicensing is not allowed; section 10
#     makes it unnecessary.
#
#       3. Protecting Users' Legal Rights From Anti-Circumvention Law.
#
#       No covered work shall be deemed part of an effective technological
#     measure under any applicable law fulfilling obligations under article
#     11 of the WIPO copyright treaty adopted on 20 December 1996, or
#     similar laws prohibiting or restricting circumvention of such
#     measures.
#
#       When you convey a covered work, you waive any legal power to forbid
#     circumvention of technological measures to the extent such circumvention
#     is effected by exercising rights under this License with respect to
#     the covered work, and you disclaim any intention to limit operation or
#     modification of the work as a means of enforcing, against the work's
#     users, your or third parties' legal rights to forbid circumvention of
#     technological measures.
#
#       4. Conveying Verbatim Copies.
#
#       You may convey verbatim copies of the Program's source code as you
#     receive it, in any medium, provided that you conspicuously and
#     appropriately publish on each copy an appropriate copyright notice;
#     keep intact all notices stating that this License and any
#     non-permissive terms added in accord with section 7 apply to the code;
#     keep intact all notices of the absence of any warranty; and give all
#     recipients a copy of this License along with the Program.
#
#       You may charge any price or no price for each copy that you convey,
#     and you may offer support or warranty protection for a fee.
#
#       5. Conveying Modified Source Versions.
#
#       You may convey a work based on the Program, or the modifications to
#     produce it from the Program, in the form of source code under the
#     terms of section 4, provided that you also meet all of these conditions:
#
#         a) The work must carry prominent notices stating that you modified
#         it, and giving a relevant date.
#
#         b) The work must carry prominent notices stating that it is
#         released under this License and any conditions added under section
#         7.  This requirement modifies the requirement in section 4 to
#         "keep intact all notices".
#
#         c) You must license the entire work, as a whole, under this
#         License to anyone who comes into possession of a copy.  This
#         License will therefore apply, along with any applicable section 7
#         additional terms, to the whole of the work, and all its parts,
#         regardless of how they are packaged.  This License gives no
#         permission to license the work in any other way, but it does not
#         invalidate such permission if you have separately received it.
#
#         d) If the work has interactive user interfaces, each must display
#         Appropriate Legal Notices; however, if the Program has interactive
#         interfaces that do not display Appropriate Legal Notices, your
#         work need not make them do so.
#
#       A compilation of a covered work with other separate and independent
#     works, which are not by their nature extensions of the covered work,
#     and which are not combined with it such as to form a larger program,
#     in or on a volume of a storage or distribution medium, is called an
#     "aggregate" if the compilation and its resulting copyright are not
#     used to limit the access or legal rights of the compilation's users
#     beyond what the individual works permit.  Inclusion of a covered work
#     in an aggregate does not cause this License to apply to the other
#     parts of the aggregate.
#
#       6. Conveying Non-Source Forms.
#
#       You may convey a covered work in object code form under the terms
#     of sections 4 and 5, provided that you also convey the
#     machine-readable Corresponding Source under the terms of this License,
#     in one of these ways:
#
#         a) Convey the object code in, or embodied in, a physical product
#         (including a physical distribution medium), accompanied by the
#         Corresponding Source fixed on a durable physical medium
#         customarily used for software interchange.
#
#         b) Convey the object code in, or embodied in, a physical product
#         (including a physical distribution medium), accompanied by a
#         written offer, valid for at least three years and valid for as
#         long as you offer spare parts or customer support for that product
#         model, to give anyone who possesses the object code either (1) a
#         copy of the Corresponding Source for all the software in the
#         product that is covered by this License, on a durable physical
#         medium customarily used for software interchange, for a price no
#         more than your reasonable cost of physically performing this
#         conveying of source, or (2) access to copy the
#         Corresponding Source from a network server at no charge.
#
#         c) Convey individual copies of the object code with a copy of the
#         written offer to provide the Corresponding Source.  This
#         alternative is allowed only occasionally and noncommercially, and
#         only if you received the object code with such an offer, in accord
#         with subsection 6b.
#
#         d) Convey the object code by offering access from a designated
#         place (gratis or for a charge), and offer equivalent access to the
#         Corresponding Source in the same way through the same place at no
#         further charge.  You need not require recipients to copy the
#         Corresponding Source along with the object code.  If the place to
#         copy the object code is a network server, the Corresponding Source
#         may be on a different server (operated by you or a third party)
#         that supports equivalent copying facilities, provided you maintain
#         clear directions next to the object code saying where to find the
#         Corresponding Source.  Regardless of what server hosts the
#         Corresponding Source, you remain obligated to ensure that it is
#         available for as long as needed to satisfy these requirements.
#
#         e) Convey the object code using peer-to-peer transmission, provided
#         you inform other peers where the object code and Corresponding
#         Source of the work are being offered to the general public at no
#         charge under subsection 6d.
#
#       A separable portion of the object code, whose source code is excluded
#     from the Corresponding Source as a System Library, need not be
#     included in conveying the object code work.
#
#       A "User Product" is either (1) a "consumer product", which means any
#     tangible personal property which is normally used for personal, family,
#     or household purposes, or (2) anything designed or sold for incorporation
#     into a dwelling.  In determining whether a product is a consumer product,
#     doubtful cases shall be resolved in favor of coverage.  For a particular
#     product received by a particular user, "normally used" refers to a
#     typical or common use of that class of product, regardless of the status
#     of the particular user or of the way in which the particular user
#     actually uses, or expects or is expected to use, the product.  A product
#     is a consumer product regardless of whether the product has substantial
#     commercial, industrial or non-consumer uses, unless such uses represent
#     the only significant mode of use of the product.
#
#       "Installation Information" for a User Product means any methods,
#     procedures, authorization keys, or other information required to install
#     and execute modified versions of a covered work in that User Product from
#     a modified version of its Corresponding Source.  The information must
#     suffice to ensure that the continued functioning of the modified object
#     code is in no case prevented or interfered with solely because
#     modification has been made.
#
#       If you convey an object code work under this section in, or with, or
#     specifically for use in, a User Product, and the conveying occurs as
#     part of a transaction in which the right of possession and use of the
#     User Product is transferred to the recipient in perpetuity or for a
#     fixed term (regardless of how the transaction is characterized), the
#     Corresponding Source conveyed under this section must be accompanied
#     by the Installation Information.  But this requirement does not apply
#     if neither you nor any third party retains the ability to install
#     modified object code on the User Product (for example, the work has
#     been installed in ROM).
#
#       The requirement to provide Installation Information does not include a
#     requirement to continue to provide support service, warranty, or updates
#     for a work that has been modified or installed by the recipient, or for
#     the User Product in which it has been modified or installed.  Access to a
#     network may be denied when the modification itself materially and
#     adversely affects the operation of the network or violates the rules and
#     protocols for communication across the network.
#
#       Corresponding Source conveyed, and Installation Information provided,
#     in accord with this section must be in a format that is publicly
#     documented (and with an implementation available to the public in
#     source code form), and must require no special password or key for
#     unpacking, reading or copying.
#
#       7. Additional Terms.
#
#       "Additional permissions" are terms that supplement the terms of this
#     License by making exceptions from one or more of its conditions.
#     Additional permissions that are applicable to the entire Program shall
#     be treated as though they were included in this License, to the extent
#     that they are valid under applicable law.  If additional permissions
#     apply only to part of the Program, that part may be used separately
#     under those permissions, but the entire Program remains governed by
#     this License without regard to the additional permissions.
#
#       When you convey a copy of a covered work, you may at your option
#     remove any additional permissions from that copy, or from any part of
#     it.  (Additional permissions may be written to require their own
#     removal in certain cases when you modify the work.)  You may place
#     additional permissions on material, added by you to a covered work,
#     for which you have or can give appropriate copyright permission.
#
#       Notwithstanding any other provision of this License, for material you
#     add to a covered work, you may (if authorized by the copyright holders of
#     that material) supplement the terms of this License with terms:
#
#         a) Disclaiming warranty or limiting liability differently from the
#         terms of sections 15 and 16 of this License; or
#
#         b) Requiring preservation of specified reasonable legal notices or
#         author attributions in that material or in the Appropriate Legal
#         Notices displayed by works containing it; or
#
#         c) Prohibiting misrepresentation of the origin of that material, or
#         requiring that modified versions of such material be marked in
#         reasonable ways as different from the original version; or
#
#         d) Limiting the use for publicity purposes of names of licensors or
#         authors of the material; or
#
#         e) Declining to grant rights under trademark law for use of some
#         trade names, trademarks, or service marks; or
#
#         f) Requiring indemnification of licensors and authors of that
#         material by anyone who conveys the material (or modified versions of
#         it) with contractual assumptions of liability to the recipient, for
#         any liability that these contractual assumptions directly impose on
#         those licensors and authors.
#
#       All other non-permissive additional terms are considered "further
#     restrictions" within the meaning of section 10.  If the Program as you
#     received it, or any part of it, contains a notice stating that it is
#     governed by this License along with a term that is a further
#     restriction, you may remove that term.  If a license document contains
#     a further restriction but permits relicensing or conveying under this
#     License, you may add to a covered work material governed by the terms
#     of that license document, provided that the further restriction does
#     not survive such relicensing or conveying.
#
#       If you add terms to a covered work in accord with this section, you
#     must place, in the relevant source files, a statement of the
#     additional terms that apply to those files, or a notice indicating
#     where to find the applicable terms.
#
#       Additional terms, permissive or non-permissive, may be stated in the
#     form of a separately written license, or stated as exceptions;
#     the above requirements apply either way.
#
#       8. Termination.
#
#       You may not propagate or modify a covered work except as expressly
#     provided under this License.  Any attempt otherwise to propagate or
#     modify it is void, and will automatically terminate your rights under
#     this License (including any patent licenses granted under the third
#     paragraph of section 11).
#
#       However, if you cease all violation of this License, then your
#     license from a particular copyright holder is reinstated (a)
#     provisionally, unless and until the copyright holder explicitly and
#     finally terminates your license, and (b) permanently, if the copyright
#     holder fails to notify you of the violation by some reasonable means
#     prior to 60 days after the cessation.
#
#       Moreover, your license from a particular copyright holder is
#     reinstated permanently if the copyright holder notifies you of the
#     violation by some reasonable means, this is the first time you have
#     received notice of violation of this License (for any work) from that
#     copyright holder, and you cure the violation prior to 30 days after
#     your receipt of the notice.
#
#       Termination of your rights under this section does not terminate the
#     licenses of parties who have received copies or rights from you under
#     this License.  If your rights have been terminated and not permanently
#     reinstated, you do not qualify to receive new licenses for the same
#     material under section 10.
#
#       9. Acceptance Not Required for Having Copies.
#
#       You are not required to accept this License in order to receive or
#     run a copy of the Program.  Ancillary propagation of a covered work
#     occurring solely as a consequence of using peer-to-peer transmission
#     to receive a copy likewise does not require acceptance.  However,
#     nothing other than this License grants you permission to propagate or
#     modify any covered work.  These actions infringe copyright if you do
#     not accept this License.  Therefore, by modifying or propagating a
#     covered work, you indicate your acceptance of this License to do so.
#
#       10. Automatic Licensing of Downstream Recipients.
#
#       Each time you convey a covered work, the recipient automatically
#     receives a license from the original licensors, to run, modify and
#     propagate that work, subject to this License.  You are not responsible
#     for enforcing compliance by third parties with this License.
#
#       An "entity transaction" is a transaction transferring control of an
#     organization, or substantially all assets of one, or subdividing an
#     organization, or merging organizations.  If propagation of a covered
#     work results from an entity transaction, each party to that
#     transaction who receives a copy of the work also receives whatever
#     licenses to the work the party's predecessor in interest had or could
#     give under the previous paragraph, plus a right to possession of the
#     Corresponding Source of the work from the predecessor in interest, if
#     the predecessor has it or can get it with reasonable efforts.
#
#       You may not impose any further restrictions on the exercise of the
#     rights granted or affirmed under this License.  For example, you may
#     not impose a license fee, royalty, or other charge for exercise of
#     rights granted under this License, and you may not initiate litigation
#     (including a cross-claim or counterclaim in a lawsuit) alleging that
#     any patent claim is infringed by making, using, selling, offering for
#     sale, or importing the Program or any portion of it.
#
#       11. Patents.
#
#       A "contributor" is a copyright holder who authorizes use under this
#     License of the Program or a work on which the Program is based.  The
#     work thus licensed is called the contributor's "contributor version".
#
#       A contributor's "essential patent claims" are all patent claims
#     owned or controlled by the contributor, whether already acquired or
#     hereafter acquired, that would be infringed by some manner, permitted
#     by this License, of making, using, or selling its contributor version,
#     but do not include claims that would be infringed only as a
#     consequence of further modification of the contributor version.  For
#     purposes of this definition, "control" includes the right to grant
#     patent sublicenses in a manner consistent with the requirements of
#     this License.
#
#       Each contributor grants you a non-exclusive, worldwide, royalty-free
#     patent license under the contributor's essential patent claims, to
#     make, use, sell, offer for sale, import and otherwise run, modify and
#     propagate the contents of its contributor version.
#
#       In the following three paragraphs, a "patent license" is any express
#     agreement or commitment, however denominated, not to enforce a patent
#     (such as an express permission to practice a patent or covenant not to
#     sue for patent infringement).  To "grant" such a patent license to a
#     party means to make such an agreement or commitment not to enforce a
#     patent against the party.
#
#       If you convey a covered work, knowingly relying on a patent license,
#     and the Corresponding Source of the work is not available for anyone
#     to copy, free of charge and under the terms of this License, through a
#     publicly available network server or other readily accessible means,
#     then you must either (1) cause the Corresponding Source to be so
#     available, or (2) arrange to deprive yourself of the benefit of the
#     patent license for this particular work, or (3) arrange, in a manner
#     consistent with the requirements of this License, to extend the patent
#     license to downstream recipients.  "Knowingly relying" means you have
#     actual knowledge that, but for the patent license, your conveying the
#     covered work in a country, or your recipient's use of the covered work
#     in a country, would infringe one or more identifiable patents in that
#     country that you have reason to believe are valid.
#
#       If, pursuant to or in connection with a single transaction or
#     arrangement, you convey, or propagate by procuring conveyance of, a
#     covered work, and grant a patent license to some of the parties
#     receiving the covered work authorizing them to use, propagate, modify
#     or convey a specific copy of the covered work, then the patent license
#     you grant is automatically extended to all recipients of the covered
#     work and works based on it.
#
#       A patent license is "discriminatory" if it does not include within
#     the scope of its coverage, prohibits the exercise of, or is
#     conditioned on the non-exercise of one or more of the rights that are
#     specifically granted under this License.  You may not convey a covered
#     work if you are a party to an arrangement with a third party that is
#     in the business of distributing software, under which you make payment
#     to the third party based on the extent of your activity of conveying
#     the work, and under which the third party grants, to any of the
#     parties who would receive the covered work from you, a discriminatory
#     patent license (a) in connection with copies of the covered work
#     conveyed by you (or copies made from those copies), or (b) primarily
#     for and in connection with specific products or compilations that
#     contain the covered work, unless you entered into that arrangement,
#     or that patent license was granted, prior to 28 March 2007.
#
#       Nothing in this License shall be construed as excluding or limiting
#     any implied license or other defenses to infringement that may
#     otherwise be available to you under applicable patent law.
#
#       12. No Surrender of Others' Freedom.
#
#       If conditions are imposed on you (whether by court order, agreement or
#     otherwise) that contradict the conditions of this License, they do not
#     excuse you from the conditions of this License.  If you cannot convey a
#     covered work so as to satisfy simultaneously your obligations under this
#     License and any other pertinent obligations, then as a consequence you may
#     not convey it at all.  For example, if you agree to terms that obligate you
#     to collect a royalty for further conveying from those to whom you convey
#     the Program, the only way you could satisfy both those terms and this
#     License would be to refrain entirely from conveying the Program.
#
#       13. Remote Network Interaction; Use with the GNU General Public License.
#
#       Notwithstanding any other provision of this License, if you modify the
#     Program, your modified version must prominently offer all users
#     interacting with it remotely through a computer network (if your version
#     supports such interaction) an opportunity to receive the Corresponding
#     Source of your version by providing access to the Corresponding Source
#     from a network server at no charge, through some standard or customary
#     means of facilitating copying of software.  This Corresponding Source
#     shall include the Corresponding Source for any work covered by version 3
#     of the GNU General Public License that is incorporated pursuant to the
#     following paragraph.
#
#       Notwithstanding any other provision of this License, you have
#     permission to link or combine any covered work with a work licensed
#     under version 3 of the GNU General Public License into a single
#     combined work, and to convey the resulting work.  The terms of this
#     License will continue to apply to the part which is the covered work,
#     but the work with which it is combined will remain governed by version
#     3 of the GNU General Public License.
#
#       14. Revised Versions of this License.
#
#       The Free Software Foundation may publish revised and/or new versions of
#     the GNU Affero General Public License from time to time.  Such new versions
#     will be similar in spirit to the present version, but may differ in detail to
#     address new problems or concerns.
#
#       Each version is given a distinguishing version number.  If the
#     Program specifies that a certain numbered version of the GNU Affero General
#     Public License "or any later version" applies to it, you have the
#     option of following the terms and conditions either of that numbered
#     version or of any later version published by the Free Software
#     Foundation.  If the Program does not specify a version number of the
#     GNU Affero General Public License, you may choose any version ever published
#     by the Free Software Foundation.
#
#       If the Program specifies that a proxy can decide which future
#     versions of the GNU Affero General Public License can be used, that proxy's
#     public statement of acceptance of a version permanently authorizes you
#     to choose that version for the Program.
#
#       Later license versions may give you additional or different
#     permissions.  However, no additional obligations are imposed on any
#     author or copyright holder as a result of your choosing to follow a
#     later version.
#
#       15. Disclaimer of Warranty.
#
#       THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
#     APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
#     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
#     OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
#     THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
#     PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
#     IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
#     ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
#
#       16. Limitation of Liability.
#
#       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
#     WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
#     THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
#     GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
#     USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
#     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
#     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
#     EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
#     SUCH DAMAGES.
#
#       17. Interpretation of Sections 15 and 16.
#
#       If the disclaimer of warranty and limitation of liability provided
#     above cannot be given local legal effect according to their terms,
#     reviewing courts shall apply local law that most closely approximates
#     an absolute waiver of all civil liability in connection with the
#     Program, unless a warranty or assumption of liability accompanies a
#     copy of the Program in return for a fee.
#
#                          END OF TERMS AND CONDITIONS
#
#                 How to Apply These Terms to Your New Programs
#
#       If you develop a new program, and you want it to be of the greatest
#     possible use to the public, the best way to achieve this is to make it
#     free software which everyone can redistribute and change under these terms.
#
#       To do so, attach the following notices to the program.  It is safest
#     to attach them to the start of each source file to most effectively
#     state the exclusion of warranty; and each file should have at least
#     the "copyright" line and a pointer to where the full notice is found.
#
#         <one line to give the program's name and a brief idea of what it does.>
#         Copyright (C) <year>  <name of author>
#
#         This program is free software: you can redistribute it and/or modify
#         it under the terms of the GNU Affero General Public License as published
#         by the Free Software Foundation, either version 3 of the License, or
#         (at your option) any later version.
#
#         This program is distributed in the hope that it will be useful,
#         but WITHOUT ANY WARRANTY; without even the implied warranty of
#         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#         GNU Affero General Public License for more details.
#
#         You should have received a copy of the GNU Affero General Public License
#         along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#     Also add information on how to contact you by electronic and paper mail.
#
#       If your software can interact with users remotely through a computer
#     network, you should also make sure that it provides a way for users to
#     get its source.  For example, if your program is a web application, its
#     interface could display a "Source" link that leads users to an archive
#     of the code.  There are many ways you could offer source, and different
#     solutions will be better for different programs; see section 13 for the
#     specific requirements.
#
#       You should also get your employer (if you work as a programmer) or school,
#     if any, to sign a "copyright disclaimer" for the program, if necessary.
#     For more information on this, and how to apply and follow the GNU AGPL, see
#     <https://www.gnu.org/licenses/>.
import asyncio
import glob
import html
import io
import json
import os
import random
import re
import subprocess
import sys
import textwrap
import time
import traceback
import urllib.request
from datetime import datetime
from html import unescape
from random import randrange
from time import sleep
from typing import List
from typing import Optional
from urllib.request import urlopen

import aiohttp
import barcode
import bs4
import emoji
import html2text
import nude
import pyfiglet
import requests
import telegraph
import text2emotion as machi
from barcode.writer import ImageWriter
from better_profanity import profanity
from bing_image_downloader import downloader
from cowpy import cow
from fontTools.ttLib import TTFont
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from gtts import gTTS
from gtts import gTTSError
from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont
from PIL import ImageOps
from PyDictionary import PyDictionary
from pymongo import MongoClient
from requests import get
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Message
from telegram import MessageEntity
from telegram import ParseMode
from telegram import ReplyKeyboardRemove
from telegram import Update
from telegram.error import BadRequest
from telegram.ext import CallbackContext
from telegram.ext import CommandHandler
from telegram.ext import Filters
from telegram.ext import run_async
from telegram.utils.helpers import escape_markdown
from telegram.utils.helpers import mention_html
from telegraph import Telegraph
from telethon import *
from telethon import events
from telethon.errors import ChatAdminRequiredError
from telethon.errors import FloodWaitError
from telethon.errors import UserAdminInvalidError
from telethon.errors import YouBlockedUserError
from telethon.tl import functions
from telethon.tl import types
from telethon.tl.functions.channels import EditBannedRequest
from telethon.tl.types import *
from tswift import Song
from wikipedia import summary
from wikipedia.exceptions import DisambiguationError
from wikipedia.exceptions import PageError

from julia import *
from julia.__main__ import GDPR
from julia.__main__ import STATS
from julia.__main__ import USER_INFO
from julia.events import juliabot
from julia.events import register
from julia.modules.helper_funcs.chat_status import is_user_admin
from julia.modules.helper_funcs.chat_status import user_admin
from julia.modules.helper_funcs.extraction import extract_user

USERS_GROUP = 4

BANNED_RIGHTS = ChatBannedRights(
    until_date=None,
    view_messages=True,
    send_messages=True,
    send_media=True,
    send_stickers=True,
    send_gifs=True,
    send_games=True,
    send_inline=True,
    embed_links=True,
)

UNBAN_RIGHTS = ChatBannedRights(
    until_date=None,
    send_messages=None,
    send_media=None,
    send_stickers=None,
    send_gifs=None,
    send_games=None,
    send_inline=None,
    embed_links=None,
)

MUTE_RIGHTS = ChatBannedRights(until_date=None, send_messages=True)

UNMUTE_RIGHTS = ChatBannedRights(until_date=None, send_messages=False)

client = MongoClient()
client = MongoClient(MONGO_DB_URI)
db = client["test"]
approved_users = db.approve


# ------ THANKS TO LONAMI ------#
async def is_register_admin(chat, user):
    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):
        return isinstance(
            (await
             tbot(functions.channels.GetParticipantRequest(chat,
                                                           user))).participant,
            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),
        )
    elif isinstance(chat, types.InputPeerChat):
        ui = await tbot.get_peer_id(user)
        ps = (await tbot(functions.messages.GetFullChatRequest(chat.chat_id)
                         )).full_chat.participants.participants
        return isinstance(
            next((p for p in ps if p.user_id == ui), None),
            (types.ChatParticipantAdmin, types.ChatParticipantCreator),
        )
    else:
        return None


async def can_ban_users(message):
    result = await tbot(
        functions.channels.GetParticipantRequest(
            channel=message.chat_id,
            user_id=message.sender_id,
        ))
    p = result.participant
    return isinstance(p, types.ChannelParticipantCreator) or (isinstance(
        p, types.ChannelParticipantAdmin) and p.admin_rights.ban_users)


# ------ THANKS TO LONAMI ------#


@user_admin
@run_async
def runs(update, context):
    RUNIT = [
        "Now you see me, now you don't.",
        "Îµ=Îµ=Îµ=Îµ=â”Œ(;ï¿£â–½ï¿£)â”˜",
        "Get back here!",
        "REEEEEEEEEEEEEEEEEE!!!!!!!",
        "Look out for the wall!",
        "Don't leave me alone with them!!",
        "You've got company!",
        "Chotto matte!",
        "Yare yare daze",
        "*Naruto run activated*",
        "*Nezuko run activated*",
        "Hey take responsibilty for what you just did!",
        "May the odds be ever in your favour.",
        "Run everyone, they just dropped a bomb ðŸ’£ðŸ’£",
        "And they disappeared forever, never to be seen again.",
        "Legend has it, they're still running.",
        "Hasta la vista, baby.",
        "Ah, what a waste. I liked that one.",
        "As The Doctor would say... RUN!",
    ]
    update.effective_message.reply_text(random.choice(RUNIT))


@user_admin
@run_async
def get_id(update: Update, context: CallbackContext):
    bot, args = context.bot, context.args
    message = update.effective_message
    chat = update.effective_chat
    msg = update.effective_message
    user_id = extract_user(msg, args)

    if user_id:

        if msg.reply_to_message and msg.reply_to_message.forward_from:

            user1 = message.reply_to_message.from_user
            user2 = message.reply_to_message.forward_from

            msg.reply_text(
                f"The original sender, {html.escape(user2.first_name)},"
                f" has an ID of <code>{user2.id}</code>.\n"
                f"The forwarder, {html.escape(user1.first_name)},"
                f" has an ID of <code>{user1.id}</code>.",
                parse_mode=ParseMode.HTML,
            )

        else:

            user = context.bot.get_chat(user_id)
            msg.reply_text(
                f"{html.escape(user.first_name)}'s id is <code>{user.id}</code>.",
                parse_mode=ParseMode.HTML,
            )

    else:

        if chat.type == "private":
            msg.reply_text(f"Your id is <code>{chat.id}</code>.",
                           parse_mode=ParseMode.HTML)

        else:
            msg.reply_text(f"This group's id is <code>{chat.id}</code>.",
                           parse_mode=ParseMode.HTML)


@run_async
def stats(update: Update, context: CallbackContext):
    update.effective_message.reply_text(
        "Current stats:\n" + "\n".join([mod.__stats__() for mod in STATS]))


profanity.load_censor_words()

client = MongoClient()
client = MongoClient(MONGO_DB_URI)
db = client["test"]
approved_users = db.approve


@user_admin
@run_async
def info(update, context):
    args = context.args
    msg = update.effective_message  # type: Optional[Message]
    user_id = extract_user(update.effective_message, args)
    chat = update.effective_chat

    if user_id:
        user = context.bot.get_chat(user_id)

    elif not msg.reply_to_message and not args:
        user = msg.from_user

    elif not msg.reply_to_message and (
            not args or
        (len(args) >= 1 and not args[0].startswith("@")
         and not args[0].isdigit()
         and not msg.parse_entities([MessageEntity.TEXT_MENTION]))):
        msg.reply_text("I can't extract a user from this.")
        return

    else:
        return

    del_msg = msg.reply_text(
        "Hold tight while I steal some data from <b>FBI Database</b>...",
        parse_mode=ParseMode.HTML,
    )

    text = ("<b>USER INFO</b>:"
            "\n\nID: <code>{}</code>"
            "\nFirst Name: {}".format(user.id, html.escape(user.first_name)))

    if user.last_name:
        text += "\nLast Name: {}".format(html.escape(user.last_name))

    if user.username:
        text += "\nUsername: @{}".format(html.escape(user.username))

    text += "\nPermanent user link: {}".format(mention_html(user.id, "link"))

    text += "\nNumber of profile pics: {}".format(
        context.bot.get_user_profile_photos(user.id).total_count)

    if user.id == OWNER_ID:
        text += "\n\nAy, this guy is my owner.\nI would never do anything against him!"

    elif user.id in SUDO_USERS:
        text += ("\n\nThis person is one of my sudo users! "
                 "Nearly as powerful as my owner - so watch it.")

    try:
        memstatus = chat.get_member(user.id).status
        if memstatus == "administrator" or memstatus == "creator":
            result = context.bot.get_chat_member(chat.id, user.id)
            if result.custom_title:
                text += f"\n\nThis user has custom title <b>{result.custom_title}</b> in this chat."
    except BadRequest:
        pass

    for mod in USER_INFO:
        try:
            mod_info = mod.__user_info__(user.id).strip()
        except TypeError:
            mod_info = mod.__user_info__(user.id, chat.id).strip()
        if mod_info:
            text += "\n\n" + mod_info

    chats = approved_users.find({})
    if not chat:
        return False
    else:
        for c in chats:
            if chat.id == c["id"] and user.id == c["user"]:
                text += "\n\n<b>This user is approved in this chat</b>"

    try:
        profile = context.bot.get_user_profile_photos(user.id).photos[0][-1]
        context.bot.sendChatAction(chat.id, "upload_photo")
        context.bot.send_photo(
            chat.id,
            photo=profile,
            caption=(text),
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True,
        )
    except IndexError:
        context.bot.sendChatAction(chat.id, "typing")
        msg.reply_text(text,
                       parse_mode=ParseMode.HTML,
                       disable_web_page_preview=True)
    finally:
        del_msg.delete()


@user_admin
@run_async
def reply_keyboard_remove(update: Update, context: CallbackContext):
    reply_keyboard = []
    reply_keyboard.append([ReplyKeyboardRemove(remove_keyboard=True)])
    reply_markup = ReplyKeyboardRemove(remove_keyboard=True)
    old_message = context.bot.send_message(
        chat_id=update.message.chat_id,
        text="Bot Keyboard removed successfully !",
        reply_markup=reply_markup,
        reply_to_message_id=update.message.message_id,
    )
    context.bot.delete_message(chat_id=update.message.chat_id,
                               message_id=old_message.message_id)


@user_admin
@run_async
def gdpr(update: Update, context: CallbackContext):
    update.effective_message.reply_text(update.effective_chat.id,
                                        "Deleting identifiable data...")
    for mod in GDPR:
        mod.__gdpr__(update.effective_user.id)
    update.effective_message.reply_text(
        "Your personal data has been deleted",
        parse_mode=ParseMode.MARKDOWN,
    )


MARKDOWN_HELP = """
Markdown is a very powerful formatting tool supported by telegram. Julia has some enhancements, to make sure that \
saved messages are correctly parsed, and to allow you to create buttons.
â€¢ <code>_italic_</code>: wrapping text with '_' will produce italic text
â€¢ <code>*bold*</code>: wrapping text with '*' will produce bold text
â€¢ <code>`code`</code>: wrapping text with '`' will produce monospaced text, also known as 'code'
â€¢ <code>[sometext](someURL)</code>: this will create a link - the message will just show <code>sometext</code>, \
and tapping on it will open the page at <code>someURL</code>.
<b>Example:</b><code>[test](example.com)</code>
â€¢ <code>[buttontext](buttonurl:someURL)</code>: this is a special enhancement to allow users to have telegram \
buttons in their markdown. <code>buttontext</code> will be what is displayed on the button, and <code>someurl</code> \
will be the url which is opened.
<b>Example:</b> <code>[This is a button](buttonurl:example.com)</code>
If you want multiple buttons on the same line, use :same, as such:
<code>[one](buttonurl://example.com)
[two](buttonurl://google.com:same)</code>
This will create two buttons on a single line, instead of one button per line.
Keep in mind that your message <b>MUST</b> contain some text other than just a button!
"""


def markdown_help_sender(update: Update):
    update.effective_message.reply_text(MARKDOWN_HELP,
                                        parse_mode=ParseMode.HTML)
    update.effective_message.reply_text(
        "Try forwarding the following message to me, and you'll see, and Use #test!"
    )
    update.effective_message.reply_text(
        "/save test This is a markdown test. _italics_, *bold*, code, "
        "[URL](example.com) [button](buttonurl:github.com) "
        "[button2](buttonurl://google.com:same)")


@run_async
@user_admin
def markdown_help(update: Update, context: CallbackContext):
    if update.effective_chat.type != "private":
        update.effective_message.reply_text(
            "Contact me in pm",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton(
                    "Markdown help",
                    url=f"t.me/{context.bot.username}?start=markdownhelp",
                )
            ]]),
        )
        return
    markdown_help_sender(update)


@run_async
@user_admin
def github(update: Update, context: CallbackContext):
    message = update.effective_message
    text = message.text[len("/git "):]
    usr = get(f"https://api.github.com/users/{text}").json()
    if usr.get("login"):
        reply_text = f"""*Name:* `{usr['name']}`
*Username:* `{usr['login']}`
*Account ID:* `{usr['id']}`
*Account type:* `{usr['type']}`
*Location:* `{usr['location']}`
*Bio:* `{usr['bio']}`
*Followers:* `{usr['followers']}`
*Following:* `{usr['following']}`
*Hireable:* `{usr['hireable']}`
*Public Repos:* `{usr['public_repos']}`
*Public Gists:* `{usr['public_gists']}`
*Email:* `{usr['email']}`
*Company:* `{usr['company']}`
*Website:* `{usr['blog']}`
*Last updated:* `{usr['updated_at']}`
*Account created at:* `{usr['created_at']}`
"""
    else:
        reply_text = "User not found. Make sure you entered valid username!"
    message.reply_text(reply_text, parse_mode=ParseMode.MARKDOWN)


@user_admin
@run_async
def repo(update: Update, context: CallbackContext):
    message = update.effective_message
    args = context.args
    text = message.text[len("/repo "):]
    usr = get(f"https://api.github.com/users/{text}/repos?per_page=300").json()
    reply_text = "*Repo*\n"
    for i in range(len(usr)):
        reply_text += f"[{usr[i]['name']}]({usr[i]['html_url']})\n"
    message.reply_text(reply_text,
                       parse_mode=ParseMode.MARKDOWN,
                       disable_web_page_preview=True)


BASE_URL = "https://del.dog"


@user_admin
@run_async
def paste(update: Update, context: CallbackContext):
    message = update.effective_message
    args = context.args
    if message.reply_to_message:
        data = message.reply_to_message.text
    elif len(args) >= 1:
        data = message.text.split(None, 1)[1]
    else:
        message.reply_text("What am I supposed to do with this?!")
        return

    r = requests.post(f"{BASE_URL}/documents", data=data.encode("utf-8"))

    if r.status_code == 404:
        update.effective_message.reply_text("Failed to reach dogbin")
        r.raise_for_status()

    res = r.json()

    if r.status_code != 200:
        update.effective_message.reply_text(res["message"])
        r.raise_for_status()

    key = res["key"]
    if res["isUrl"]:
        reply = f"Shortened URL: {BASE_URL}/{key}\nYou can view stats, etc. [here]({BASE_URL}/v/{key})"
    else:
        reply = f"{BASE_URL}/{key}"
    update.effective_message.reply_text(reply,
                                        parse_mode=ParseMode.MARKDOWN,
                                        disable_web_page_preview=True)


@user_admin
@run_async
def get_paste_content(update: Update, context: CallbackContext):
    message = update.effective_message
    args = context.args
    if len(args) >= 1:
        key = args[0]
    else:
        message.reply_text("Please supply a paste key!")
        return

    format_normal = f"{BASE_URL}/"
    format_view = f"{BASE_URL}/v/"

    if key.startswith(format_view):
        key = key[len(format_view):]
    elif key.startswith(format_normal):
        key = key[len(format_normal):]

    r = requests.get(f"{BASE_URL}/raw/{key}")

    if r.status_code != 200:
        try:
            res = r.json()
            update.effective_message.reply_text(res["message"])
        except Exception:
            if r.status_code == 404:
                update.effective_message.reply_text("Failed to reach dogbin")
            else:
                update.effective_message.reply_text("Unknown error occured")
        r.raise_for_status()

    update.effective_message.reply_text("```" + escape_markdown(r.text) +
                                        "```",
                                        parse_mode=ParseMode.MARKDOWN)


@user_admin
@run_async
def get_paste_stats(update: Update, context: CallbackContext):
    message = update.effective_message
    args = context.args
    if len(args) >= 1:
        key = args[0]
    else:
        message.reply_text("Please supply a paste key!")
        return

    format_normal = f"{BASE_URL}/"
    format_view = f"{BASE_URL}/v/"

    if key.startswith(format_view):
        key = key[len(format_view):]
    elif key.startswith(format_normal):
        key = key[len(format_normal):]

    r = requests.get(f"{BASE_URL}/documents/{key}")

    if r.status_code != 200:
        try:
            res = r.json()
            update.effective_message.reply_text(res["message"])
        except Exception:
            if r.status_code == 404:
                update.effective_message.reply_text("Failed to reach dogbin")
            else:
                update.effective_message.reply_text("Unknown error occured")
        r.raise_for_status()

    document = r.json()["document"]
    key = document["_id"]
    views = document["viewCount"]
    reply = f"Stats for **[/{key}]({BASE_URL}/{key})**:\nViews: `{views}`"
    update.effective_message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)


@register(pattern="^/tts (.*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    input_str = event.pattern_match.group(1)
    reply_to_id = event.message.id
    if event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        text = previous_message.message
        lan = input_str
    elif "|" in input_str:
        lan, text = input_str.split("|")
    else:
        await event.reply(
            "Invalid Syntax\nFormat `/tts lang | text`\nFor eg: `/tts en | hello`"
        )
        return
    text = text.strip()
    lan = lan.strip()
    try:
        tts = gTTS(text, tld="com", lang=lan)
        tts.save("k.mp3")
    except AssertionError:
        await event.reply("The text is empty.\n"
                          "Nothing left to speak after pre-precessing, "
                          "tokenizing and cleaning.")
        return
    except ValueError:
        await event.reply("Language is not supported.")
        return
    except RuntimeError:
        await event.reply("Error loading the languages dictionary.")
        return
    except gTTSError:
        await event.reply("Error in Google Text-to-Speech API request !")
        return
    with open("k.mp3", "r"):
        await event.client.send_file(event.chat_id,
                                     "k.mp3",
                                     voice_note=True,
                                     reply_to=reply_to_id)
        os.remove("k.mp3")


@register(pattern=r"^/wiki (.*)")
async def wiki(wiki_q):
    """ For .google command, fetch content from Wikipedia. """
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if wiki_q.is_group:
        if await is_register_admin(wiki_q.input_chat,
                                   wiki_q.message.sender_id):
            pass
        elif wiki_q.chat_id == iid and wiki_q.from_id == userss:
            pass
        else:
            return
    match = wiki_q.pattern_match.group(1)
    try:
        summary(match)
    except DisambiguationError as error:
        await wiki_q.reply(f"Disambiguated page found.\n\n{error}")
        return
    except PageError as pageerror:
        await wiki_q.reply(f"Page not found.\n\n{pageerror}")
        return
    result = summary(match)
    if len(result) >= 4096:
        file = open("output.txt", "w+")
        file.write(result)
        file.close()
        await wiki_q.client.send_file(
            wiki_q.chat_id,
            "output.txt",
            reply_to=wiki_q.id,
            caption="`Output too large, sending as file`",
        )
        if os.path.exists("output.txt"):
            os.remove("output.txt")
        return
    await wiki_q.reply("**Search:**\n`" + match + "`\n\n**Result:**\n" +
                       result)


@register(pattern="^/google (.*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    # SHOW_DESCRIPTION = False
    # + " -inurl:(htm|html|php|pls|txt) intitle:index.of \"last modified\" (mkv|mp4|avi|epub|pdf|mp3)"
    input_str = event.pattern_match.group(1)
    input_url = "https://bots.shrimadhavuk.me/search/?q={}".format(input_str)
    headers = {"USER-AGENT": "UniBorg"}
    response = requests.get(input_url, headers=headers).json()
    output_str = " "
    for result in response["results"]:
        text = result.get("title")
        url = result.get("url")
        description = result.get("description")
        last = html2text.html2text(description)
        output_str += "[{}]({})\n{}\n".format(text, url, last)
    await event.reply("{}".format(output_str),
                      link_preview=False,
                      parse_mode="Markdown")


@register(pattern="^/weather (.*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    sample_url = (
        "https://api.openweathermap.org/data/2.5/weather?q={}&APPID={}&units=metric"
    )
    input_str = event.pattern_match.group(1)
    async with aiohttp.ClientSession() as session:
        response_api_zero = await session.get(
            sample_url.format(input_str, OPENWEATHERMAP_ID))
    response_api = await response_api_zero.json()
    if response_api["cod"] == 200:
        country_code = response_api["sys"]["country"]
        country_time_zone = int(response_api["timezone"])
        sun_rise_time = int(response_api["sys"]["sunrise"]) + country_time_zone
        sun_set_time = int(response_api["sys"]["sunset"]) + country_time_zone
        await event.reply("""**Location**: {}
**Temperature**: {}Â°Ð¡
    __minimium__: {}Â°Ð¡
    __maximum__ : {}Â°Ð¡
**Humidity**: {}%
**Wind**: {}m/s
**Clouds**: {}hpa
**Sunrise**: {} {}
**Sunset**: {} {}""".format(
            input_str,
            response_api["main"]["temp"],
            response_api["main"]["temp_min"],
            response_api["main"]["temp_max"],
            response_api["main"]["humidity"],
            response_api["wind"]["speed"],
            response_api["clouds"]["all"],
            # response_api["main"]["pressure"],
            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(sun_rise_time)),
            country_code,
            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(sun_set_time)),
            country_code,
        ))
    else:
        await event.reply(response_api["message"])


@register(pattern="^/wttr (.*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
    elif event.chat_id == iid and event.from_id == userss:
        pass
    else:
        return
    sample_url = "https://wttr.in/{}.png"
    # logger.info(sample_url)
    input_str = event.pattern_match.group(1)
    async with aiohttp.ClientSession() as session:
        response_api_zero = await session.get(sample_url.format(input_str))
        # logger.info(response_api_zero)
        response_api = await response_api_zero.read()
        with io.BytesIO(response_api) as out_file:
            await event.reply(file=out_file)


@register(pattern="^/figlet (.*)")
async def figlet(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    input_str = event.pattern_match.group(1)
    result = pyfiglet.figlet_format(input_str)
    await event.respond("`{}`".format(result))


@register(pattern="^/img (.*)")
async def img_sampler(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    query = event.pattern_match.group(1)
    jit = f'"{query}"'
    downloader.download(
        jit,
        limit=5,
        output_dir="store",
        adult_filter_off=False,
        force_replace=False,
        timeout=60,
    )
    os.chdir(f'./store/"{query}"')
    types = ("*.png", "*.jpeg", "*.jpg")  # the tuple of file types
    files_grabbed = []
    for files in types:
        files_grabbed.extend(glob.glob(files))
    await event.client.send_file(event.chat_id,
                                 files_grabbed,
                                 reply_to=event.id)
    os.chdir("/app/MissJuliaRobot/MissJuliaRobot")
    os.system("rm -rf store")


@run_async
@user_admin
def shrug(update: Update, context: CallbackContext):
    default_msg = r"Â¯\_(ãƒ„)_/Â¯"
    message = update.effective_message
    if message.reply_to_message:
        message.reply_to_message.reply_text(default_msg)
    else:
        message.reply_text(default_msg)


dictionary = PyDictionary()


@run_async
@user_admin
def define(update: Update, context: CallbackContext):
    message = update.effective_message
    text = message.text[len("/define "):]
    word = f"{text}"
    let = dictionary.meaning(word)
    set = str(let)
    jet = set.replace("{", "")
    net = jet.replace("}", "")
    got = net.replace("'", "")
    message.reply_text(got)


@run_async
@user_admin
def synonyms(update: Update, context: CallbackContext):
    message = update.effective_message
    text = message.text[len("/define "):]
    word = f"{text}"
    let = dictionary.synonym(word)
    set = str(let)
    jet = set.replace("{", "")
    net = jet.replace("}", "")
    got = net.replace("'", "")
    message.reply_text(got)


@run_async
@user_admin
def antonyms(update: Update, context: CallbackContext):
    message = update.effective_message
    text = message.text[len("/define "):]
    word = f"{text}"
    let = dictionary.antonym(word)
    set = str(let)
    jet = set.replace("{", "")
    net = jet.replace("}", "")
    got = net.replace("'", "")
    message.reply_text(got)


@register(pattern="^/yt (.*)")
async def yts_search(video_q):
    # For .yts command, do a YouTube search from Telegram.
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if video_q.is_group:
        if await is_register_admin(video_q.input_chat,
                                   video_q.message.sender_id):
            pass
        elif video_q.chat_id == iid and video_q.from_id == userss:
            pass
        else:
            return
    query = video_q.pattern_match.group(1)
    result = ""

    if not YOUTUBE_API_KEY:
        await video_q.reply(
            "`Error: YouTube API key missing! Add it to environment vars or config.env.`"
        )
        return

    full_response = await youtube_search(query)
    videos_json = full_response[1]

    for video in videos_json:
        title = f"{unescape(video['snippet']['title'])}"
        link = f"https://youtu.be/{video['id']['videoId']}"
        result += f"{title}\n{link}\n\n"

    reply_text = f"**Search Query:**\n`{query}`\n\n**Results:**\n\n{result}"

    await video_q.reply(reply_text, link_preview=False)


async def youtube_search(query,
                         order="relevance",
                         token=None,
                         location=None,
                         location_radius=None):
    """ Do a YouTube search. """
    youtube = build("youtube",
                    "v3",
                    developerKey=YOUTUBE_API_KEY,
                    cache_discovery=False)
    search_response = (youtube.search().list(
        q=query,
        type="video",
        pageToken=token,
        order=order,
        part="id,snippet",
        maxResults=10,
        location=location,
        locationRadius=location_radius,
    ).execute())

    videos = []

    for search_result in search_response.get("items", []):
        if search_result["id"]["kind"] == "youtube#video":
            videos.append(search_result)
    try:
        nexttok = search_response["nextPageToken"]
        return (nexttok, videos)
    except HttpError:
        nexttok = "last_page"
        return (nexttok, videos)
    except KeyError:
        nexttok = "KeyError, try again."
        return (nexttok, videos)


"""Get Administrators of any Chat*
Syntax: .userlist"""


@register(pattern="^/users$")
async def get_users(show):
    if not show.is_group:
        await show.reply("Are you sure this is a group?")
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if show.is_group:
        if await is_register_admin(show.input_chat, show.message.sender_id):
            pass
        elif show.chat_id == iid and show.from_id == userss:
            pass
        else:
            return
    info = await show.client.get_entity(show.chat_id)
    title = info.title if info.title else "this chat"
    mentions = "Users in {}: \n".format(title)
    async for user in show.client.iter_participants(show.chat_id):
        if not user.deleted:
            mentions += f"\n[{user.first_name}](tg://user?id={user.id}) {user.id}"
        else:
            mentions += f"\nDeleted Account {user.id}"
    file = open("userslist.txt", "w+")
    file.write(mentions)
    file.close()
    await show.client.send_file(
        show.chat_id,
        "userslist.txt",
        caption="Users in {}".format(title),
        reply_to=show.id,
    )
    os.remove("userslist.txt")


@register(pattern="^/app (.*)")
async def apk(e):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if e.is_group:
        if await is_register_admin(e.input_chat, e.message.sender_id):
            pass
        elif e.chat_id == iid and e.from_id == userss:
            pass
        else:
            return
    try:
        app_name = e.pattern_match.group(1)
        remove_space = app_name.split(" ")
        final_name = "+".join(remove_space)
        page = requests.get("https://play.google.com/store/search?q=" +
                            final_name + "&c=apps")
        lnk = str(page.status_code)
        soup = bs4.BeautifulSoup(page.content, "lxml", from_encoding="utf-8")
        results = soup.findAll("div", "ZmHEEd")
        app_name = (results[0].findNext("div", "Vpfmgd").findNext(
            "div", "WsMG1c nnK0zc").text)
        app_dev = results[0].findNext("div",
                                      "Vpfmgd").findNext("div", "KoLSrc").text
        app_dev_link = ("https://play.google.com" + results[0].findNext(
            "div", "Vpfmgd").findNext("a", "mnKHRc")["href"])
        app_rating = (results[0].findNext("div", "Vpfmgd").findNext(
            "div", "pf5lIe").find("div")["aria-label"])
        app_link = ("https://play.google.com" + results[0].findNext(
            "div", "Vpfmgd").findNext("div", "vU6FJ p63iDd").a["href"])
        app_icon = (results[0].findNext("div", "Vpfmgd").findNext(
            "div", "uzcko").img["data-src"])
        app_details = "<a href='" + app_icon + "'>ðŸ“²&#8203;</a>"
        app_details += " <b>" + app_name + "</b>"
        app_details += ("\n\n<code>Developer :</code> <a href='" +
                        app_dev_link + "'>" + app_dev + "</a>")
        app_details += "\n<code>Rating :</code> " + app_rating.replace(
            "Rated ", "â­ ").replace(" out of ", "/").replace(
                " stars", "", 1).replace(" stars", "â­ ").replace("five", "5")
        app_details += ("\n<code>Features :</code> <a href='" + app_link +
                        "'>View in Play Store</a>")
        app_details += "\n\n===> @MissJuliaRobot <==="
        await e.reply(app_details, link_preview=True, parse_mode="HTML")
    except IndexError:
        await e.reply(
            "No result found in search. Please enter **Valid app name**")
    except Exception as err:
        await e.reply("Exception Occured:- " + str(err))


@register(pattern=r"^/(\w+)say (.*)")
async def univsaye(cowmsg):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if cowmsg.is_group:
        if await is_register_admin(cowmsg.input_chat,
                                   cowmsg.message.sender_id):
            pass
        elif cowmsg.chat_id == iid and cowmsg.from_id == userss:
            pass
        else:
            return
    """ For .cowsay module, uniborg wrapper for cow which says things. """
    if not cowmsg.text[0].isalpha() and cowmsg.text[0] not in ("#", "@"):
        arg = cowmsg.pattern_match.group(1).lower()
        text = cowmsg.pattern_match.group(2)

        if arg == "cow":
            arg = "default"
        if arg not in cow.COWACTERS:
            return
        cheese = cow.get_cow(arg)
        cheese = cheese()

        await cowmsg.reply(f"`{cheese.milk(text).replace('`', 'Â´')}`")


@register(pattern="^/zombies(?: |$)(.*)")
async def rm_deletedacc(show):
    """ For .delusers command, list all the ghost/deleted accounts in a chat. """
    con = show.pattern_match.group(1).lower()
    del_u = 0
    del_status = "`No deleted accounts found, Group is cleaned as Hell`"

    if show.is_private:
        return

    if show.is_group:
        if str(show.from_id) in str(OWNER_ID):
            pass
        else:
            if not await can_ban_users(message=show):
                return

    if con != "clean":
        await show.reply("`Searching for zombie accounts...`")
        async for user in show.client.iter_participants(show.chat_id):
            if user.deleted:
                del_u += 1

        if del_u > 0:
            del_status = f"Found **{del_u}** deleted account(s) in this group,\
            \nclean them by using `/zombies clean`"

        await show.reply(del_status)
        return

    await show.reply("`Deleting deleted accounts...`")
    del_u = 0
    del_a = 0

    async for user in show.client.iter_participants(show.chat_id):
        if user.deleted:
            try:
                await show.client(
                    EditBannedRequest(show.chat_id, user.id, BANNED_RIGHTS))
            except ChatAdminRequiredError:
                await show.reply("`I don't have ban rights in this group`")
                return
            except UserAdminInvalidError:
                del_u -= 1
                del_a += 1
            await show.client(
                EditBannedRequest(show.chat_id, user.id, UNBAN_RIGHTS))
            del_u += 1

    if del_u > 0:
        del_status = f"Cleaned **{del_u}** deleted account(s)"

    if del_a > 0:
        del_status = f"Cleaned **{del_u}** deleted account(s) \
        \n**{del_a}** deleted admin accounts are not removed"

    await show.reply(del_status)


def ocr_space_file(filename,
                   overlay=False,
                   api_key=OCR_SPACE_API_KEY,
                   language="eng"):
    payload = {
        "isOverlayRequired": overlay,
        "apikey": api_key,
        "language": language,
    }
    with open(filename, "rb") as f:
        r = requests.post(
            "https://api.ocr.space/parse/image",
            files={filename: f},
            data=payload,
        )
    return r.json()


def ocr_space_url(url,
                  overlay=False,
                  api_key=OCR_SPACE_API_KEY,
                  language="eng"):
    payload = {
        "url": url,
        "isOverlayRequired": overlay,
        "apikey": api_key,
        "language": language,
    }
    r = requests.post(
        "https://api.ocr.space/parse/image",
        data=payload,
    )
    return r.json()


def progress(current, total):
    logger.info("Downloaded {} of {}\nCompleted {}".format(
        current, total, (current / total) * 100))


@register(pattern="^/img2textlang")
async def get_ocr_languages(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    languages = {}
    languages["English"] = "eng"
    languages["Arabic"] = "ara"
    languages["Bulgarian"] = "bul"
    languages["Chinese (Simplified)"] = "chs"
    languages["Chinese (Traditional)"] = "cht"
    languages["Croatian"] = "hrv"
    languages["Czech"] = "cze"
    languages["Danish"] = "dan"
    languages["Dutch"] = "dut"
    languages["Finnish"] = "fin"
    languages["French"] = "fre"
    languages["German"] = "ger"
    languages["Greek"] = "gre"
    languages["Hungarian"] = "hun"
    languages["Korean"] = "kor"
    languages["Italian"] = "ita"
    languages["Japanese"] = "jpn"
    languages["Polish"] = "pol"
    languages["Portuguese"] = "por"
    languages["Russian"] = "rus"
    languages["Slovenian"] = "slv"
    languages["Spanish"] = "spa"
    languages["Swedish"] = "swe"
    languages["Turkish"] = "tur"
    a = json.dumps(languages, sort_keys=True, indent=4)
    await event.reply(str(a))


@register(pattern="^/img2text (.*)")
async def parse_ocr_space_api(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    await event.reply("Processing ...")
    if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):
        os.makedirs(TEMP_DOWNLOAD_DIRECTORY)
    lang_code = event.pattern_match.group(1)
    downloaded_file_name = await event.client.download_media(
        await event.get_reply_message(), TEMP_DOWNLOAD_DIRECTORY)
    if downloaded_file_name.endswith((".webp")):
        downloaded_file_name = conv_image(downloaded_file_name)
    test_file = ocr_space_file(filename=downloaded_file_name,
                               language=lang_code)
    ParsedText = "hmm"
    try:
        ParsedText = test_file["ParsedResults"][0]["ParsedText"]
        ProcessingTimeInMilliseconds = str(
            int(test_file["ProcessingTimeInMilliseconds"]) // 1000)
    except Exception as e:
        await event.reply(
            "Error :\n `{}`\nReport This to @MissJuliaSupport\n\n`{}`".format(
                str(e), json.dumps(test_file, sort_keys=True, indent=4)))
    else:
        await event.reply("Read Document in {} seconds. \n{}".format(
            ProcessingTimeInMilliseconds, ParsedText))
    os.remove(downloaded_file_name)


def conv_image(image):
    im = Image.open(image)
    im.save(image, "PNG")
    new_file_name = image + ".png"
    os.rename(image, new_file_name)
    return new_file_name


"""Speech to Text
Syntax: .stt <Language Code> as reply to a speech message"""


@register(pattern="^/stt$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    start = datetime.datetime.now()
    if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):
        os.makedirs(TEMP_DOWNLOAD_DIRECTORY)
    await event.reply("Downloading to Julia's server for Analysis ...")
    if event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        required_file_name = await event.client.download_media(
            previous_message, TEMP_DOWNLOAD_DIRECTORY)
        if IBM_WATSON_CRED_URL is None or IBM_WATSON_CRED_PASSWORD is None:
            await event.reply(
                "You need to set the required ENV variables for this module. \nModule stopping"
            )
        else:
            await event.reply("Starting analysis")
            headers = {
                "Content-Type": previous_message.media.document.mime_type,
            }
            data = open(required_file_name, "rb").read()
            response = requests.post(
                IBM_WATSON_CRED_URL + "/v1/recognize",
                headers=headers,
                data=data,
                auth=("apikey", IBM_WATSON_CRED_PASSWORD),
            )
            r = response.json()
            if "results" in r:
                # process the json to appropriate string format
                results = r["results"]
                transcript_response = ""
                transcript_confidence = ""
                for alternative in results:
                    alternatives = alternative["alternatives"][0]
                    transcript_response += " " + str(
                        alternatives["transcript"])
                    transcript_confidence += (" " +
                                              str(alternatives["confidence"]) +
                                              " + ")
                end = datetime.datetime.now()
                ms = (end - start).seconds
                if transcript_response != "":
                    string_to_show = "Language: `English`\nTRANSCRIPT: `{}`\nTime Taken: {} seconds\nConfidence: `{}`".format(
                        transcript_response, ms, transcript_confidence)
                else:
                    string_to_show = "Language: `English`\nTime Taken: {} seconds\n**No Results Found**".format(
                        ms)
                await event.reply(string_to_show)
            else:
                await event.reply(r["error"])
            # now, remove the temporary file
            os.remove(required_file_name)
    else:
        await event.reply(
            "Reply to a voice message, to get the text out of it.")


@register(pattern="^/news$")
async def _(event):
    if event.is_group:
        return
    if event.fwd_from:
        return

    news_url = "https://news.google.com/rss?hl=en-IN&gl=IN&ceid=IN:en"
    Client = urlopen(news_url)
    xml_page = Client.read()
    Client.close()
    soup_page = soup(xml_page, "xml")
    news_list = soup_page.findAll("item")
    for news in news_list:
        title = news.title.text
        text = news.link.text
        date = news.pubDate.text
        seperator = "-" * 50
        l = "\n"
        lastisthis = title + l + text + l + date + l + seperator
        await event.reply(lastisthis)


@register(pattern="^/dice$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    input_str = print(randrange(7))
    r = await event.reply(file=InputMediaDice(""))
    if input_str:
        try:
            required_number = int(input_str)
            while not r.media.value == required_number:
                await r.delete()
                r = await event.reply(file=InputMediaDice(""))
        except BaseException:
            pass


@register(pattern="^/basketball$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    input_str = print(randrange(6))
    r = await event.reply(file=InputMediaDice("ðŸ€"))
    if input_str:
        try:
            required_number = int(input_str)
            while not r.media.value == required_number:
                await r.delete()
                r = await event.reply(file=InputMediaDice("ðŸ€"))
        except BaseException:
            pass


@register(pattern="^/dart$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    input_str = print(randrange(7))
    r = await event.reply(file=InputMediaDice("ðŸŽ¯"))
    if input_str:
        try:
            required_number = int(input_str)
            while not r.media.value == required_number:
                await r.delete()
                r = await event.reply(file=InputMediaDice("ðŸŽ¯"))
        except BaseException:
            pass


# Simple lyrics module using tswift by @TheRealPhoenix


@run_async
@user_admin
def lyrics(update: Update, context: CallbackContext):
    msg = update.effective_message
    song = ""
    args = context.args
    query = " ".join(args)
    if not query:
        msg.reply_text("You haven't specified which song to look for!")
        return
    else:
        song = Song.find_song(query)
        if song:
            if song.lyrics:
                reply = song.format()
            else:
                reply = "Couldn't find any lyrics for that song!"
        else:
            reply = "Song not found!"
        if len(reply) > 4090:
            with open("lyrics.txt", "w") as f:
                f.write(f"{reply}\n\n\nOwO UwU OwO")
            with open("lyrics.txt", "rb") as f:
                msg.reply_document(
                    document=f,
                    caption=
                    "Message length exceeded max limit! Sending as a text file.",
                )
        else:
            msg.reply_text(reply)


# Made by @MissJulia_Robot


@register(pattern=r"^/julia(?: |$)([\s\S]*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    if not event.reply_to_msg_id:
        i = event.pattern_match.group(1)
        appid = WOLFRAM_ID
        server = f"https://api.wolframalpha.com/v1/spoken?appid={appid}&i={i}"
        res = get(server)
        await event.reply(f"**{i}**\n\n" + res.text, parse_mode="Markdown")

    if event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        required_file_name = await event.client.download_media(
            previous_message, TEMP_DOWNLOAD_DIRECTORY)
        if IBM_WATSON_CRED_URL is None or IBM_WATSON_CRED_PASSWORD is None:
            await event.reply(
                "You need to set the required ENV variables for this module. \nModule stopping"
            )
        else:
            headers = {
                "Content-Type": previous_message.media.document.mime_type,
            }
            data = open(required_file_name, "rb").read()
            response = requests.post(
                IBM_WATSON_CRED_URL + "/v1/recognize",
                headers=headers,
                data=data,
                auth=("apikey", IBM_WATSON_CRED_PASSWORD),
            )
            r = response.json()
            if "results" in r:
                # process the json to appropriate string format
                results = r["results"]
                transcript_response = ""
                transcript_confidence = ""
                for alternative in results:
                    alternatives = alternative["alternatives"][0]
                    transcript_response += " " + str(
                        alternatives["transcript"])
                if transcript_response != "":
                    string_to_show = "{}".format(transcript_response)
                    appid = WOLFRAM_ID
                    server = f"https://api.wolframalpha.com/v1/spoken?appid={appid}&i={string_to_show}"
                    res = get(server)
                    answer = res.text
                    try:
                        tts = gTTS(answer, tld="com", lang="en")
                        tts.save("results.mp3")
                    except AssertionError:
                        return
                    except ValueError:
                        return
                    except RuntimeError:
                        return
                    except gTTSError:
                        return
                    with open("results.mp3", "r"):
                        await event.client.send_file(
                            event.chat_id,
                            "results.mp3",
                            voice_note=True,
                            reply_to=event.id,
                        )
                    os.remove("results.mp3")
                else:
                    try:
                        answer = "Sorry I can't recognise your query"
                        tts = gTTS(answer, tld="com", lang="en")
                        tts.save("results.mp3")
                    except AssertionError:
                        return
                    except ValueError:
                        return
                    except RuntimeError:
                        return
                    except gTTSError:
                        return
                    with open("results.mp3", "r"):
                        await event.client.send_file(
                            event.chat_id,
                            "results.mp3",
                            voice_note=True,
                            reply_to=event.id,
                        )
                    os.remove("results.mp3")
            else:
                await event.reply("API Failure !")
                os.remove(required_file_name)


telegraph = Telegraph()
telegraph.create_account(short_name="Julia")


@register(pattern="^/torrent (.*)")
async def tor_search(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    str = event.pattern_match.group(1)
    let = f'"{str}"'
    jit = subprocess.check_output(["we-get", "-s", let, "-J"])
    proc = jit.decode()
    sit = proc.replace("{", "")
    pit = sit.replace("}", "")
    op = pit.replace(",", "")
    seta = f"Magnets for {str} are below:"
    response = telegraph.create_page(seta, html_content=op)
    await event.reply(
        "Magnet Links for {}:\n\nhttps://telegra.ph/{}".format(
            str, response["path"]),
        link_preview=False,
    )


@register(pattern="^/fortune$")
async def fortunate(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    jit = subprocess.check_output(["python", "fortune.py"])
    pit = jit.decode()
    await event.reply(pit)


@register(pattern=r"^/phone (.*)")
async def phone(event):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    information = event.pattern_match.group(1)
    number = information
    key = "fe65b94e78fc2e3234c1c6ed1b771abd"
    api = ("http://apilayer.net/api/validate?access_key=" + key + "&number=" +
           number + "&country_code=&format=1")
    output = requests.get(api)
    content = output.text
    obj = json.loads(content)
    country_code = obj["country_code"]
    country_name = obj["country_name"]
    location = obj["location"]
    carrier = obj["carrier"]
    line_type = obj["line_type"]
    validornot = obj["valid"]
    aa = "Valid: " + str(validornot)
    a = "Phone number: " + str(number)
    b = "Country: " + str(country_code)
    c = "Country Name: " + str(country_name)
    d = "Location: " + str(location)
    e = "Carrier: " + str(carrier)
    f = "Device: " + str(line_type)
    g = f"{aa}\n{a}\n{b}\n{c}\n{d}\n{e}\n{f}"
    await event.reply(g)


def online_within(participant):
    status = participant.status
    print(status)
    if (isinstance(status, types.UserStatusOnline)
            or (status, types.UserStatusRecently)
            or (status, types.UserStatusEmpty)
            or (status, types.UserStatusLastMonth)
            or (status, types.UserStatusLastWeek) or participant.bot):
        return False
    else:
        last_seen = (status.was_online
                     if isinstance(status, types.UserStatusOffline) else None)
        print(last_seen)


@register(pattern="^/kickthefools$")
async def _(event):
    if event.fwd_from:
        return

    if event.is_private:
        return

    if not await can_ban_users(message=event):
        return

    c = 0
    KICK_RIGHTS = ChatBannedRights(until_date=None, view_messages=True)
    done = await event.reply("Working ...")
    async for i in event.client.iter_participants(event.chat_id):

        if isinstance(i.status, UserStatusLastMonth):
            status = await event.client(
                EditBannedRequest(event.chat_id, i, KICK_RIGHTS))
            if not status:
                return
            else:
                c = c + 1

        if isinstance(i.status, UserStatusLastWeek):
            status = await event.client(
                EditBannedRequest(event.chat_id, i, KICK_RIGHTS))
            if not status:
                return
            else:
                c = c + 1

    if c == 0:
        await done.edit("Got no one to kick ðŸ˜”")
        return

    required_string = "Successfully Kicked **{}** users"
    await event.reply(required_string.format(c))


@register(pattern="^/camscanner$")
async def asciiart(event):
    if event.fwd_from:
        return
    if not event.from_id:
        await event.reply("Reply To A Image Plox..")
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    directory = "./"
    test = os.listdir(directory)
    for item in test:
        if item.endswith(".jpg"):
            os.remove(os.path.join(directory, item))
        elif item.endswith(".png"):
            os.remove(os.path.join(directory, item))
        elif item.endswith(".jpeg"):
            os.remove(os.path.join(directory, item))
    reply_msg = await event.get_reply_message()
    downloaded_file_name = await event.client.download_media(reply_msg, "./")
    let = f"{downloaded_file_name}"
    subprocess.run(["python", "scan.py", "--image", let])
    fuck = await event.client.upload_file("./scanned.jpg")
    await event.client.send_file(event.chat_id, fuck)
    directory = "./"
    test = os.listdir(directory)
    for item in test:
        if item.endswith(".jpg"):
            os.remove(os.path.join(directory, item))
        elif item.endswith(".png"):
            os.remove(os.path.join(directory, item))
        elif item.endswith(".jpeg"):
            os.remove(os.path.join(directory, item))


@register(pattern="^/barcode ?(.*)")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    start = datetime.datetime.now()
    input_str = event.pattern_match.group(1)
    message = "SYNTAX: `.barcode <long text to include>`"
    reply_msg_id = event.message.id
    if input_str:
        message = input_str
    elif event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        reply_msg_id = previous_message.id
        if previous_message.media:
            downloaded_file_name = await event.client.download_media(
                previous_message,
                Config.TEMP_DOWNLOAD_DIRECTORY,
            )
            m_list = None
            with open(downloaded_file_name, "rb") as fd:
                m_list = fd.readlines()
            message = ""
            for m in m_list:
                message += m.decode("UTF-8") + "\r\n"
            os.remove(downloaded_file_name)
        else:
            message = previous_message.message
    else:
        message = "SYNTAX: `.barcode <long text to include>`"
    bar_code_type = "code128"
    try:
        bar_code_mode_f = barcode.get(bar_code_type,
                                      message,
                                      writer=ImageWriter())
        filename = bar_code_mode_f.save(bar_code_type)
        await event.client.send_file(
            event.chat_id,
            filename,
            caption=message,
            reply_to=reply_msg_id,
        )
        os.remove(filename)
    except Exception as e:
        await event.reply(str(e))
        return
    end = datetime.now()
    ms = (end - start).seconds
    await event.reply("Created BarCode in {} seconds".format(ms))


@register(pattern="^/unbanall$")
async def _(event):
    if event.is_private:
        await event.reply("You can use this command in groups but not in PM's")
        return

    if event.is_group:
        if str(event.from_id) in str(OWNER_ID):
            pass
        else:
            if not await can_ban_users(message=event):
                return

    done = await event.reply("Searching Participant Lists.")
    p = 0
    async for i in event.client.iter_participants(
            event.chat_id, filter=ChannelParticipantsKicked, aggressive=True):
        rights = ChatBannedRights(until_date=0, view_messages=False)
        try:
            await tbot(
                functions.channels.EditBannedRequest(event.chat_id, i, rights))
        except FloodWaitError as ex:
            logger.warn("sleeping for {} seconds".format(ex.seconds))
            sleep(ex.seconds)
        except Exception as ex:
            await event.reply(str(ex))
        else:
            p += 1

    if p == 0:
        await done.edit("No one is banned in this chat")
        return
    required_string = "Successfully unbanned **{}** users"
    await event.reply(required_string.format(p))


@register(pattern="^/unmuteall$")
async def _(event):
    if event.fwd_from:
        return
    if event.is_private:
        await event.reply("You can use this command in groups but not in PM's")
        return
    if event.is_group:
        if str(event.from_id) in str(OWNER_ID):
            pass
        else:
            if not await can_ban_users(message=event):
                return

    done = await event.reply("Working ...")
    p = 0
    async for i in event.client.iter_participants(
            event.chat_id, filter=ChannelParticipantsBanned, aggressive=True):
        rights = ChatBannedRights(
            until_date=0,
            send_messages=False,
        )
        try:
            await tbot(
                functions.channels.EditBannedRequest(event.chat_id, i, rights))
        except FloodWaitError as ex:
            logger.warn("sleeping for {} seconds".format(ex.seconds))
            sleep(ex.seconds)
        except Exception as ex:
            await event.reply(str(ex))
        else:
            p += 1

    if p == 0:
        await done.edit("No one is muted in this chat")
        return
    required_string = "Successfully unmuted **{}** users"
    await event.reply(required_string.format(p))


# Oringinal Source from Nicegrill: https://github.com/erenmetesar/NiceGrill/
# Ported to Lynda by: @pokurt

COLORS = [
    "#F07975",
    "#F49F69",
    "#F9C84A",
    "#8CC56E",
    "#6CC7DC",
    "#80C1FA",
    "#BCB3F9",
    "#E181AC",
]


async def process(msg, user, client, reply, replied=None):
    if not os.path.isdir("resources"):
        os.mkdir("resources", 0o755)
        urllib.request.urlretrieve(
            "https://github.com/erenmetesar/modules-repo/raw/master/Roboto-Regular.ttf",
            "resources/Roboto-Regular.ttf",
        )
        urllib.request.urlretrieve(
            "https://github.com/erenmetesar/modules-repo/raw/master/Quivira.otf",
            "resources/Quivira.otf",
        )
        urllib.request.urlretrieve(
            "https://github.com/erenmetesar/modules-repo/raw/master/Roboto-Medium.ttf",
            "resources/Roboto-Medium.ttf",
        )
        urllib.request.urlretrieve(
            "https://github.com/erenmetesar/modules-repo/raw/master/DroidSansMono.ttf",
            "resources/DroidSansMono.ttf",
        )
        urllib.request.urlretrieve(
            "https://github.com/erenmetesar/modules-repo/raw/master/Roboto-Italic.ttf",
            "resources/Roboto-Italic.ttf",
        )

    # ImportÄ±ng fonts and gettings the size of text
    font = ImageFont.truetype("resources/Roboto-Medium.ttf",
                              43,
                              encoding="utf-16")
    font2 = ImageFont.truetype("resources/Roboto-Regular.ttf",
                               33,
                               encoding="utf-16")
    mono = ImageFont.truetype("resources/DroidSansMono.ttf",
                              30,
                              encoding="utf-16")
    italic = ImageFont.truetype("resources/Roboto-Italic.ttf",
                                33,
                                encoding="utf-16")
    fallback = ImageFont.truetype("resources/Quivira.otf",
                                  43,
                                  encoding="utf-16")

    # Splitting text
    maxlength = 0
    width = 0
    text = []
    for line in msg.split("\n"):
        length = len(line)
        if length > 43:
            text += textwrap.wrap(line, 43)
            maxlength = 43
            if width < fallback.getsize(line[:43])[0]:
                if "MessageEntityCode" in str(reply.entities):
                    width = mono.getsize(line[:43])[0] + 30
                else:
                    width = fallback.getsize(line[:43])[0]
            next
        else:
            text.append(line + "\n")
            if width < fallback.getsize(line)[0]:
                if "MessageEntityCode" in str(reply.entities):
                    width = mono.getsize(line)[0] + 30
                else:
                    width = fallback.getsize(line)[0]
            if maxlength < length:
                maxlength = length

    title = ""
    try:
        details = await client(
            functions.channels.GetParticipantRequest(reply.chat_id, user.id))
        if isinstance(details.participant, types.ChannelParticipantCreator):
            title = details.participant.rank if details.participant.rank else "Creator"
        elif isinstance(details.participant, types.ChannelParticipantAdmin):
            title = details.participant.rank if details.participant.rank else "Admin"
    except TypeError:
        pass
    titlewidth = font2.getsize(title)[0]

    # Get user name
    lname = "" if not user.last_name else user.last_name
    tot = user.first_name + " " + lname

    namewidth = fallback.getsize(tot)[0] + 10

    if namewidth > width:
        width = namewidth
    width += titlewidth + 30 if titlewidth > width - namewidth else -(
        titlewidth - 30)
    height = len(text) * 40

    # Profile Photo BG
    pfpbg = Image.new("RGBA", (125, 600), (0, 0, 0, 0))

    # Draw Template
    top, middle, bottom = await drawer(width, height)
    # Profile Photo Check and Fetch
    yes = False
    color = random.choice(COLORS)
    async for photo in client.iter_profile_photos(user, limit=1):
        yes = True
    if yes:
        pfp = await client.download_profile_photo(user)
        paste = Image.open(pfp)
        os.remove(pfp)
        paste.thumbnail((105, 105))

        # Mask
        mask_im = Image.new("L", paste.size, 0)
        draw = ImageDraw.Draw(mask_im)
        draw.ellipse((0, 0, 105, 105), fill=255)

        # Apply Mask
        pfpbg.paste(paste, (0, 0), mask_im)
    else:
        paste, color = await no_photo(user, tot)
        pfpbg.paste(paste, (0, 0))

    # Creating a big canvas to gather all the elements
    canvassize = (
        middle.width + pfpbg.width,
        top.height + middle.height + bottom.height,
    )
    canvas = Image.new("RGBA", canvassize)
    draw = ImageDraw.Draw(canvas)

    y = 80
    if replied:
        # Creating a big canvas to gather all the elements
        replname = "" if not replied.sender.last_name else replied.sender.last_name
        reptot = replied.sender.first_name + " " + replname
        replywidth = font2.getsize(reptot)[0]
        if reply.sticker:
            sticker = await reply.download_media()
            stimg = Image.open(sticker)
            canvas = canvas.resize(
                (stimg.width + pfpbg.width, stimg.height + 160))
            top = Image.new("RGBA", (200 + stimg.width, 300),
                            (29, 29, 29, 255))
            draw = ImageDraw.Draw(top)
            await replied_user(draw, reptot,
                               replied.message.replace("\n", " "), 20)
            top = top.crop((135, 70, top.width, 300))
            canvas.paste(pfpbg, (0, 0))
            canvas.paste(top, (pfpbg.width + 10, 0))
            canvas.paste(stimg, (pfpbg.width + 10, 140))
            os.remove(sticker)
            return True, canvas
        canvas = canvas.resize((canvas.width + 60, canvas.height + 120))
        top, middle, bottom = await drawer(middle.width + 60, height + 105)
        canvas.paste(pfpbg, (0, 0))
        canvas.paste(top, (pfpbg.width, 0))
        canvas.paste(middle, (pfpbg.width, top.height))
        canvas.paste(bottom, (pfpbg.width, top.height + middle.height))
        draw = ImageDraw.Draw(canvas)
        if replied.sticker:
            replied.text = "Sticker"
        elif replied.photo:
            replied.text = "Photo"
        elif replied.audio:
            replied.text = "Audio"
        elif replied.voice:
            replied.text = "Voice Message"
        elif replied.document:
            replied.text = "Document"
        await replied_user(
            draw,
            reptot,
            replied.message.replace("\n", " "),
            maxlength + len(title),
            len(title),
        )
        y = 200
    elif reply.sticker:
        sticker = await reply.download_media()
        stimg = Image.open(sticker)
        canvas = canvas.resize(
            (stimg.width + pfpbg.width + 30, stimg.height + 10))
        canvas.paste(pfpbg, (0, 0))
        canvas.paste(stimg, (pfpbg.width + 10, 10))
        os.remove(sticker)
        return True, canvas
    elif reply.document and not reply.audio and not reply.audio:
        docname = ".".join(
            reply.document.attributes[-1].file_name.split(".")[:-1])
        doctype = reply.document.attributes[-1].file_name.split(
            ".")[-1].upper()
        if reply.document.size < 1024:
            docsize = str(reply.document.size) + " Bytes"
        elif reply.document.size < 1048576:
            docsize = str(round(reply.document.size / 1024, 2)) + " KB "
        elif reply.document.size < 1073741824:
            docsize = str(round(reply.document.size / 1024**2, 2)) + " MB "
        else:
            docsize = str(round(reply.document.size / 1024**3, 2)) + " GB "
        docbglen = (font.getsize(docsize)[0]
                    if font.getsize(docsize)[0] > font.getsize(docname)[0] else
                    font.getsize(docname)[0])
        canvas = canvas.resize((pfpbg.width + width + docbglen, 160 + height))
        top, middle, bottom = await drawer(width + docbglen, height + 30)
        canvas.paste(pfpbg, (0, 0))
        canvas.paste(top, (pfpbg.width, 0))
        canvas.paste(middle, (pfpbg.width, top.height))
        canvas.paste(bottom, (pfpbg.width, top.height + middle.height))
        canvas = await doctype(docname, docsize, doctype, canvas)
        y = 80 if text else 0
    else:
        canvas.paste(pfpbg, (0, 0))
        canvas.paste(top, (pfpbg.width, 0))
        canvas.paste(middle, (pfpbg.width, top.height))
        canvas.paste(bottom, (pfpbg.width, top.height + middle.height))
        y = 85

    # Writing User's Name
    space = pfpbg.width + 30
    namefallback = ImageFont.truetype("resources/Quivira.otf",
                                      43,
                                      encoding="utf-16")
    for letter in tot:
        if letter in emoji.UNICODE_EMOJI:
            newemoji, mask = await emoji_fetch(letter)
            canvas.paste(newemoji, (space, 24), mask)
            space += 40
        else:
            if not await fontTest(letter):
                draw.text((space, 20), letter, font=namefallback, fill=color)
                space += namefallback.getsize(letter)[0]
            else:
                draw.text((space, 20), letter, font=font, fill=color)
                space += font.getsize(letter)[0]

    if title:
        draw.text((canvas.width - titlewidth - 20, 25),
                  title,
                  font=font2,
                  fill="#898989")

    # Writing all separating emojis and regular texts
    x = pfpbg.width + 30
    bold, mono, italic, link = await get_entity(reply)
    mdlength = 0
    index = 0
    emojicount = 0
    textfallback = ImageFont.truetype("resources/Quivira.otf",
                                      33,
                                      encoding="utf-16")
    textcolor = "white"
    for line in text:
        for letter in line:
            index = (msg.find(letter)
                     if emojicount == 0 else msg.find(letter) + emojicount)
            for offset, length in bold.items():
                if index in range(offset, length):
                    font2 = ImageFont.truetype("resources/Roboto-Medium.ttf",
                                               33,
                                               encoding="utf-16")
                    textcolor = "white"
            for offset, length in italic.items():
                if index in range(offset, length):
                    font2 = ImageFont.truetype("resources/Roboto-Italic.ttf",
                                               33,
                                               encoding="utf-16")
                    textcolor = "white"
            for offset, length in mono.items():
                if index in range(offset, length):
                    font2 = ImageFont.truetype("resources/DroidSansMono.ttf",
                                               30,
                                               encoding="utf-16")
                    textcolor = "white"
            for offset, length in link.items():
                if index in range(offset, length):
                    font2 = ImageFont.truetype("resources/Roboto-Regular.ttf",
                                               30,
                                               encoding="utf-16")
                    textcolor = "#898989"
            if letter in emoji.UNICODE_EMOJI:
                newemoji, mask = await emoji_fetch(letter)
                canvas.paste(newemoji, (x, y - 2), mask)
                x += 45
                emojicount += 1
            else:
                if not await fontTest(letter):
                    draw.text((x, y),
                              letter,
                              font=textfallback,
                              fill=textcolor)
                    x += textfallback.getsize(letter)[0]
                else:
                    draw.text((x, y), letter, font=font2, fill=textcolor)
                    x += font2.getsize(letter)[0]
            msg = msg.replace(letter, "Â¶", 1)
        y += 40
        x = pfpbg.width + 30
    return True, canvas


async def drawer(width, height):
    # Top part
    top = Image.new("RGBA", (width, 20), (0, 0, 0, 0))
    draw = ImageDraw.Draw(top)
    draw.line((10, 0, top.width - 20, 0), fill=(29, 29, 29, 255), width=50)
    draw.pieslice((0, 0, 30, 50), 180, 270, fill=(29, 29, 29, 255))
    draw.pieslice((top.width - 75, 0, top.width, 50),
                  270,
                  360,
                  fill=(29, 29, 29, 255))

    # Middle part
    middle = Image.new("RGBA", (top.width, height + 75), (29, 29, 29, 255))

    # Bottom part
    bottom = ImageOps.flip(top)

    return top, middle, bottom


async def fontTest(letter):
    test = TTFont("resources/Roboto-Medium.ttf")
    for table in test["cmap"].tables:
        if ord(letter) in table.cmap.keys():
            return True


async def get_entity(msg):
    bold = {0: 0}
    italic = {0: 0}
    mono = {0: 0}
    link = {0: 0}
    if not msg.entities:
        return bold, mono, italic, link
    for entity in msg.entities:
        if isinstance(entity, types.MessageEntityBold):
            bold[entity.offset] = entity.offset + entity.length
        elif isinstance(entity, types.MessageEntityItalic):
            italic[entity.offset] = entity.offset + entity.length
        elif isinstance(entity, types.MessageEntityCode):
            mono[entity.offset] = entity.offset + entity.length
        elif isinstance(entity, types.MessageEntityUrl):
            link[entity.offset] = entity.offset + entity.length
        elif isinstance(entity, types.MessageEntityTextUrl):
            link[entity.offset] = entity.offset + entity.length
        elif isinstance(entity, types.MessageEntityMention):
            link[entity.offset] = entity.offset + entity.length
    return bold, mono, italic, link


async def doctype(name, size, type, canvas):
    font = ImageFont.truetype("resources/Roboto-Medium.ttf", 38)
    doc = Image.new("RGBA", (130, 130), (29, 29, 29, 255))
    draw = ImageDraw.Draw(doc)
    draw.ellipse((0, 0, 130, 130), fill="#434343")
    draw.line((66, 28, 66, 53), width=14, fill="white")
    draw.polygon([(67, 77), (90, 53), (42, 53)], fill="white")
    draw.line((40, 87, 90, 87), width=8, fill="white")
    canvas.paste(doc, (160, 23))
    draw2 = ImageDraw.Draw(canvas)
    draw2.text((320, 40), name, font=font, fill="white")
    draw2.text((320, 97), size + type, font=font, fill="#AAAAAA")
    return canvas


async def no_photo(reply, tot):
    pfp = Image.new("RGBA", (105, 105), (0, 0, 0, 0))
    pen = ImageDraw.Draw(pfp)
    color = random.choice(COLORS)
    pen.ellipse((0, 0, 105, 105), fill=color)
    letter = "" if not tot else tot[0]
    font = ImageFont.truetype("resources/Roboto-Regular.ttf", 60)
    pen.text((32, 17), letter, font=font, fill="white")
    return pfp, color


async def emoji_fetch(emoji):
    emojis = json.loads(
        urllib.request.urlopen(
            "https://github.com/erenmetesar/modules-repo/raw/master/emojis.txt"
        ).read().decode())
    if emoji in emojis:
        img = emojis[emoji]
        return await transparent(
            urllib.request.urlretrieve(img, "resources/emoji.png")[0])
    else:
        img = emojis["â›”"]
        return await transparent(
            urllib.request.urlretrieve(img, "resources/emoji.png")[0])


async def transparent(emoji):
    emoji = Image.open(emoji).convert("RGBA")
    emoji.thumbnail((40, 40))

    # Mask
    mask = Image.new("L", (40, 40), 0)
    draw = ImageDraw.Draw(mask)
    draw.ellipse((0, 0, 40, 40), fill=255)
    return emoji, mask


async def replied_user(draw, tot, text, maxlength, title):
    namefont = ImageFont.truetype("resources/Roboto-Medium.ttf", 38)
    namefallback = ImageFont.truetype("resources/Quivira.otf", 38)
    textfont = ImageFont.truetype("resources/Roboto-Regular.ttf", 32)
    textfallback = ImageFont.truetype("resources/Roboto-Medium.ttf", 38)
    maxlength = maxlength + 7 if maxlength < 10 else maxlength
    text = text[:maxlength - 2] + ".." if len(text) > maxlength else text
    draw.line((165, 90, 165, 170), width=5, fill="white")
    space = 0
    for letter in tot:
        if not await fontTest(letter):
            draw.text((180 + space, 86),
                      letter,
                      font=namefallback,
                      fill="#888888")
            space += namefallback.getsize(letter)[0]
        else:
            draw.text((180 + space, 86), letter, font=namefont, fill="#888888")
            space += namefont.getsize(letter)[0]
    space = 0
    for letter in text:
        if not await fontTest(letter):
            draw.text((180 + space, 132),
                      letter,
                      font=textfallback,
                      fill="#888888")
            space += textfallback.getsize(letter)[0]
        else:
            draw.text((180 + space, 132), letter, font=textfont, fill="white")
            space += textfont.getsize(letter)[0]


@register(pattern="^/quotly$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    reply = await event.get_reply_message()
    msg = reply.message
    repliedreply = await reply.get_reply_message()
    user = (await event.client.get_entity(reply.forward.sender)
            if reply.fwd_from else reply.sender)
    res, canvas = await process(msg, user, event.client, reply, repliedreply)
    if not res:
        return
    canvas.save("sticker.webp")
    await event.client.send_file(event.chat_id,
                                 "sticker.webp",
                                 reply_to=event.reply_to_msg_id)
    os.remove("sticker.webp")


BOTLOG_CHATID = os.environ.get("BOTLOG_CHATID")

EMOJI_PATTERN = re.compile(
    "["
    "\U0001F1E0-\U0001F1FF"  # flags (iOS)
    "\U0001F300-\U0001F5FF"  # symbols & pictographs
    "\U0001F600-\U0001F64F"  # emoticons
    "\U0001F680-\U0001F6FF"  # transport & map symbols
    "\U0001F700-\U0001F77F"  # alchemical symbols
    "\U0001F780-\U0001F7FF"  # Geometric Shapes Extended
    "\U0001F800-\U0001F8FF"  # Supplemental Arrows-C
    "\U0001F900-\U0001F9FF"  # Supplemental Symbols and Pictographs
    "\U0001FA00-\U0001FA6F"  # Chess Symbols
    "\U0001FA70-\U0001FAFF"  # Symbols and Pictographs Extended-A
    "\U00002702-\U000027B0"  # Dingbats
    "]+")


def deEmojify(inputString: str) -> str:
    """Remove emojis and other non-safe characters from string"""
    return re.sub(EMOJI_PATTERN, "", inputString)


# Made by @AyushChatterjee


@juliabot(pattern="/animated")
async def waifu(animu):
    animus = [20, 32, 33, 40, 41, 42, 58]
    sticcers = await animu.client.inline_query(
        "stickerizerbot", f"#{random.choice(animus)}{(deEmojify(newtext))}")
    null = await sticcers[0].download_media(TEMP_DOWNLOAD_DIRECTORY)
    global bara
    bara = str(null)

    print("sticker downloaded successfully")


@register(pattern="^/animate (.*)")
async def stickerizer(event):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    global newtext
    newtext = event.pattern_match.group(1)
    myid = int("-1009655116")
    entity = await event.client.get_entity(OWNER_USERNAME)
    randika = await event.client.send_message(entity, "/animated")
    await asyncio.sleep(3)
    await event.client.send_file(event.chat_id, bara, reply_to=event.id)
    os.remove(bara)
    await randika.delete()


# Made by @AyushChatterjee


@juliabot(pattern="/saved")
async def saat(event):
    chat = "@FileToLinkTGbot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1011636686))
            await event.client.send_file(chat, debloat)
            response = await response
        except YouBlockedUserError:
            return
        if not response:
            return
        if response.text.startswith("ðŸ”—"):
            #    my_string= response.text
            #    p = re.compile(":(.*)")
            #    global holababy
            #    holababy = p.findall(my_string)
            global holababy
            holababy = response.text


@register(pattern="^/savefile$")
async def savel(event):
    if event.fwd_from:
        return
    if not event.reply_to_msg_id:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    reply_message = await event.get_reply_message()
    global debloat
    debloat = await reply_message.download_media(TEMP_DOWNLOAD_DIRECTORY)
    entity = await event.client.get_entity(OWNER_USERNAME)
    randika = await event.client.send_message(entity, "/saved")
    await event.reply(f"{holababy}")
    await randika.delete()


@register(pattern="^/sticklet (.*)")
async def sticklet(event):
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    R = random.randint(0, 256)
    G = random.randint(0, 256)
    B = random.randint(0, 256)

    # get the input text
    # the text on which we would like to do the magic on
    sticktext = event.pattern_match.group(1)

    # delete the userbot command,
    # i don't know why this is required
    # await event.delete()

    # https://docs.python.org/3/library/textwrap.html#textwrap.wrap
    sticktext = textwrap.wrap(sticktext, width=10)
    # converts back the list to a string
    sticktext = "\n".join(sticktext)

    image = Image.new("RGBA", (512, 512), (255, 255, 255, 0))
    draw = ImageDraw.Draw(image)
    fontsize = 230

    FONT_FILE = await get_font_file(ubot, "@IndianBot_Fonts")

    font = ImageFont.truetype(FONT_FILE, size=fontsize)

    while draw.multiline_textsize(sticktext, font=font) > (512, 512):
        fontsize -= 3
        font = ImageFont.truetype(FONT_FILE, size=fontsize)

    width, height = draw.multiline_textsize(sticktext, font=font)
    draw.multiline_text(((512 - width) / 2, (512 - height) / 2),
                        sticktext,
                        font=font,
                        fill=(R, G, B))

    image_stream = io.BytesIO()
    image_stream.name = "@Julia.webp"
    image.save(image_stream, "WebP")
    image_stream.seek(0)

    # finally, reply the sticker
    await event.reply(file=image_stream,
                      reply_to=event.message.reply_to_msg_id)
    # replacing upper line with this to get reply tags

    # cleanup
    try:
        os.remove(FONT_FILE)
    except BaseException:
        pass


async def get_font_file(client, channel_id):
    # first get the font messages
    font_file_message_s = await client.get_messages(
        entity=channel_id,
        filter=InputMessagesFilterDocument,
        # this might cause FLOOD WAIT,
        # if used too many times
        limit=None,
    )
    # get a random font from the list of fonts
    # https://docs.python.org/3/library/random.html#random.choice
    font_file_message = random.choice(font_file_message_s)
    # download and return the file path
    return await client.download_media(font_file_message)


# NEW EMOTION DETECTOR MADE BY @AyushChatterjee


@register(pattern="^/emotion$")
async def _(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    reply = await event.get_reply_message()
    msg = reply.message
    let = str(machi.get_emotion(msg))
    # m = let.replace("'Happy'", "ðŸ˜€")
    n = let.replace("{", "")
    o = n.replace("}", "")
    # p = o.replace("'Angry'", "ðŸ˜¡")
    # q = p.replace("'Sad'", "ðŸ˜­")
    # r = q.replace("'Surprise'", "ðŸ˜®")
    # s = r.replace("'Fear'", "")
    t = o.replace(", ", "\n\n")
    await event.reply(t)


@run_async
@user_admin
def echo(update: Update, context: CallbackContext):
    args = update.effective_message.text.split(None, 1)
    message = update.effective_message

    if message.reply_to_message:
        message.reply_to_message.reply_text(args[1],
                                            parse_mode="MARKDOWN",
                                            disable_web_page_preview=True)
    else:
        message.reply_text(args[1],
                           quote=False,
                           parse_mode="MARKDOWN",
                           disable_web_page_preview=True)
    message.delete()


SLAP_ALEXA_TEMPLATES = (
    "Slap me one more time and I'll mute you.",
    "Stop slapping me. REEEEEEEEEEEEEE.",
    [
        "I am muting you for a minute.",  # normal reply
        "Stop slapping me just because I can't mute you. REEEEEEEEEE.",  # reply to admin
        "tmute",  # command
        "Shut up!",
        "Silence!",
    ],
)

SLAP_TEMPLATES = (
    "{user2} was killed by magic.",
    "{user2} starved without pats.",
    "{user2} was knocked into the void by {user1}.",
    "{user2} fainted.",
    "{user2} is out of usable Pokemon! {user2} whited out!.",
    "{user2} is out of usable Pokemon! {user2} blacked out!.",
    "{user2} got rekt.",
    "{user2}'s melon was split by {user1}.",
    "{user2} was sliced and diced by {user1}.",
    "{user2} played hot-potato with a grenade.",
    "{user2} was knifed by {user1}.",
    "{user2} ate a grenade.",
    "{user2} is what's for dinner!",
    "{user2} was terminated by {user1}.",
    "{user1} spammed {user2}'s email.",
    "{user1} RSA-encrypted {user2} and deleted the private key.",
    "{user1} put {user2} in the friendzone.",
    "{user1} slaps {user2} with a DMCA takedown request!",
    "{user2} got a house call from Doctor {user1}.",
    "{user1} beheaded {user2}.",
    "{user2} got stoned...by an angry mob.",
    "{user1} sued the pants off {user2}.",
    "{user2} was one-hit KO'd by {user1}.",
    "{user1} sent {user2} down the memory hole.",
    "{user2} was a mistake. - '{user1}' ",
    "{user2} was made redundant.",
    "{user1} {hits} {user2} with a bat!.",
    "{user1} {hits} {user2} with a Taijutsu Kick!.",
    "{user1} {hits} {user2} with X-Gloves!.",
    "{user1} {hits} {user2} with a Jet Punch!.",
    "{user1} {hits} {user2} with a Jet Pistol!.",
    "{user1} {hits} {user2} with a United States of Smash!.",
    "{user1} {hits} {user2} with a Detroit Smash!.",
    "{user1} {hits} {user2} with a Texas Smash!.",
    "{user1} {hits} {user2} with a California Smash!.",
    "{user1} {hits} {user2} with a New Hampshire Smash!.",
    "{user1} {hits} {user2} with a Missouri Smash!.",
    "{user1} {hits} {user2} with a Carolina Smash!.",
    "{user1} {hits} {user2} with a King Kong Gun!.",
    "{user1} {hits} {user2} with a baseball bat - metal one.!.",
    "*Serious punches {user2}*.",
    "*Normal punches {user2}*.",
    "*Consecutive Normal punches {user2}*.",
    "*Two Handed Consecutive Normal Punches {user2}*.",
    "*Ignores {user2} to let them die of embarassment*.",
    "*points at {user2}* What's with this sassy... lost child?.",
    "*Hits {user2} with a Fire Tornado*.",
    "{user1} pokes {user2} in the eye !",
    "{user1} pokes {user2} on the sides!",
    "{user1} pokes {user2}!",
    "{user1} pokes {user2} with a needle!",
    "{user1} pokes {user2} with a pen!",
    "{user1} pokes {user2} with a stun gun!",
    "{user2} is secretly a Furry!",
    "Hey Everybody! {user1} is asking me to be mean!",
    "( ï½¥_ï½¥)ï¾‰âŒ’â—~* (ï½¥.ï½¥;) <-{user2}",
    "Take this {user2}\n(ï¾‰ï¾ŸÐ”ï¾Ÿ)ï¾‰ ))))â—~* ",
    "Here {user2} hold this\n(ï½€ãƒ»Ï‰ãƒ»)ã¤ â—~ï¼Š",
    "( ãƒ»_ãƒ»)ãƒŽÎžâ—~*  {user2}\nDieeeee!!.",
    "( ãƒ»âˆ€ãƒ»)ï½’é¹µ~<â‰ªå·›;ï¾ŸÐ”ï¾Ÿ)ï¾‰\n*Bug sprays {user2}*.",
    "( ï¾ŸÐ”ï¾Ÿ)ï¾‰å ~<å·›å·›å·›.\n-{user2} You pest!",
    r"( ã†-Â´)ã¥ï¸»â•¦ÌµÌµÌ¿â•¤â”€â”€ \(Ëšâ˜Ëšâ€)/ {user2}.",
    "{user1} {hits} {user2} with a {item}.",
    "{user1} {hits} {user2} in the face with a {item}.",
    "{user1} {hits} {user2} around a bit with a {item}.",
    "{user1} {throws} a {item} at {user2}.",
    "{user1} grabs a {item} and {throws} it at {user2}'s face.",
    "{user1} launches a {item} in {user2}'s general direction.",
    "{user1} starts slapping {user2} silly with a {item}.",
    "{user1} pins {user2} down and repeatedly {hits} them with a {item}.",
    "{user1} grabs up a {item} and {hits} {user2} with it.",
    "{user1} ties {user2} to a chair and {throws} a {item} at them.",
    "{user1} gave a friendly push to help {user2} learn to swim in lava.",
    "{user1} bullied {user2}.",
    "Nyaan ate {user2}'s leg. *nomnomnom*",
    "{user1} {throws} a master ball at {user2}, resistance is futile.",
    "{user1} hits {user2} with an action beam...bbbbbb (à¸‡ãƒ»Ï‰ãƒ»)à¸‡ ====*",
    "{user1} ara ara's {user2}.",
    "{user1} ora ora's {user2}.",
    "{user1} muda muda's {user2}.",
    "{user2} was turned into a Jojo reference!",
    "{user1} hits {user2} with {item}.",
    "Round 2!..Ready? .. FIGHT!!",
    "WhoPixel will oof {user2} to infinity and beyond.",
    "{user2} ate a bat and discovered a new disease.",
    "{user1} folded {user2} into a paper plane",
    "{user1} served {user2} some bat soup.",
    "{user2} was sent to his home, the planet of the apes.",
    "{user1} kicked {user2} out of a moving train.",
    "{user2} just killed John Wickâ€™s dog.",
    "{user1} performed an Avada Kedavra spell on {user2}.",
    "{user1} subjected {user2} to a fiery furnace.",
    "Sakura Haruno just got more useful than {user2}",
    "{user1} unplugged {user2}'s life support.",
    "{user1} subscribed {user2}' to 5 years of bad internet.",
    "You know whatâ€™s worse than Dad jokes? {user2}!",
    "{user1} took all of {user2}'s cookies.",
    "{user2} wa mou.......Shindeiru! - {user1}.",
    "{user2} lost his race piece!",  # No game no life reference
    "Shut up {user2}, you are just {user2}.",  # No game no life reference
    "{user1} hits {user2} with Aka si anse!",  # No game no life reference
    "@NeoTheKitty scratches {user2}",  # Pixels pet cat - @NeoTheKitty
    "Majin buu ate {user2}",  # Dbz
    "Goblin slayer slays {user2}",  # Goblin Slayer
)

ITEMS = (
    "cast iron skillet",
    "angry meow",
    "cricket bat",
    "wooden cane",
    "shovel",
    "toaster",
    "book",
    "laptop",
    "rubber chicken",
    "spiked bat",
    "heavy rock",
    "chunk of dirt",
    "ton of bricks",
    "rasengan",
    "spirit bomb",
    "100-Type Guanyin Bodhisattva",
    "rasenshuriken",
    "Murasame",
    "ban",
    "chunchunmaru",
    "KubikiribÅchÅ",
    "rasengan",
    "spherical flying kat",
)

THROW = (
    "throws",
    "flings",
    "chucks",
    "hurls",
)

HIT = (
    "hits",
    "whacks",
    "slaps",
    "smacks",
    "bashes",
    "pats",
)


@run_async
@user_admin
def slap(update: Update, context: CallbackContext):
    bot, args = context.bot, context.args
    message = update.effective_message
    chat = update.effective_chat

    reply_text = (message.reply_to_message.reply_text
                  if message.reply_to_message else message.reply_text)

    curr_user = html.escape(message.from_user.first_name)
    user_id = extract_user(message, args)

    if user_id == bot.id:
        temp = random.choice(fun_strings.SLAP_ALEXA_TEMPLATES)

        if isinstance(temp, list):
            if temp[2] == "tmute":
                if is_user_admin(chat, message.from_user.id):
                    reply_text(temp[1])
                    return

                mutetime = int(time.time() + 60)
                bot.restrict_chat_member(
                    chat.id,
                    message.from_user.id,
                    until_date=mutetime,
                    permissions=ChatPermissions(can_send_messages=False),
                )
            reply_text(temp[0])
        else:
            reply_text(temp)
        return

    if user_id:

        slapped_user = bot.get_chat(user_id)
        user1 = curr_user
        user2 = html.escape(slapped_user.first_name)

    else:
        user1 = bot.first_name
        user2 = curr_user

    temp = random.choice(fun_strings.SLAP_TEMPLATES)
    item = random.choice(fun_strings.ITEMS)
    hit = random.choice(fun_strings.HIT)
    throw = random.choice(fun_strings.THROW)

    reply = temp.format(user1=user1,
                        user2=user2,
                        item=item,
                        hits=hit,
                        throws=throw)

    reply_text(reply, parse_mode=ParseMode.HTML)


def get_readable_time(seconds: int) -> str:
    count = 0
    ping_time = ""
    time_list = []
    time_suffix_list = ["s", "m", "h", "days"]

    while count < 4:
        count += 1
        if count < 3:
            remainder, result = divmod(seconds, 60)
        else:
            remainder, result = divmod(seconds, 24)
        if seconds == 0 and remainder == 0:
            break
        time_list.append(int(result))
        seconds = int(remainder)

    for x in range(len(time_list)):
        time_list[x] = str(time_list[x]) + time_suffix_list[x]
    if len(time_list) == 4:
        ping_time += time_list.pop() + ", "

    time_list.reverse()
    ping_time += ":".join(time_list)

    return ping_time


@run_async
@user_admin
def ping(update: Update, context: CallbackContext):
    msg = update.effective_message

    start_time = time.time()
    message = msg.reply_text("Pinging...")
    end_time = time.time()
    telegram_ping = str(round((end_time - start_time) * 1000, 3)) + " ms"
    uptime = get_readable_time((time.time() - StartTime))

    message.edit_text(
        "PONG!!\n"
        "<b>Time Taken:</b> <code>{}</code>\n"
        "<b>Service uptime:</b> <code>{}</code>".format(telegram_ping, uptime),
        parse_mode=ParseMode.HTML,
    )


@register(pattern="^/howdoi (.*)")
async def howdoi(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    str = event.pattern_match.group(1)
    jit = subprocess.check_output(["howdoi", f"{str}"])
    pit = jit.decode()
    await event.reply(pit)


async def inline_query(client, bot, query):
    from telethon import custom

    return custom.InlineResults(
        client,
        await client(
            functions.messages.GetInlineBotResultsRequest(
                bot=bot,
                peer="me",
                query=query,
                offset="",
                geo_point=types.InputGeoPointEmpty(),
            )),
    )


## -- THANKS TO LONAMI FOR THIS FUNCTION --#

# -- MADE BY @MissJulia_Robot


@juliabot(pattern="^/gameed")
async def ramdomgames(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee", "1+"))[0].click("MissJuliaRobot",
                                                              hide_via=True)


@register(pattern="^/mathbattle$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return

    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/gameed")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jsusxjxhxhxshsjs")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "MotoFX"))[0].click("MissJuliaRobot")


@register(pattern="^/motofx$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jsusxjxhxhxshsjs")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jsuskhfkhdxjzhsjs")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Penalty"))[0].click("MissJuliaRobot",
                                                   hide_via=True)


@register(pattern="^/penaltyshooter$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jsuskhfkhdxjzhsjs")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jslgggfsslaxvuoqdjlxvqs")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee", "F1"))[0].click("MissJuliaRobot",
                                                              hide_via=True)


@register(pattern="^/racingcar$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jslgggfsslaxvuoqdjlxvqs")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jsdndbbduoqdjlxvqs")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Karate"))[1].click("MissJuliaRobot",
                                                  hide_via=True)


@register(pattern="^/karate$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jsdndbbduoqdjlxvqs")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jsdndbafjaffajlxvqs")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Football"))[0].click("MissJuliaRobot",
                                                    hide_via=True)


@register(pattern="^/footballstar$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jsdndbafjaffajlxvqs")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/jsddjdhiwws")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Neon"))[0].click("MissJuliaRobot",
                                                hide_via=True)


@register(pattern="^/neonblaster$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/jsddjdhiwws")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/whwyywwhewws")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Disco"))[0].click("MissJuliaRobot",
                                                 hide_via=True)


@register(pattern="^/discoball$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/whwyywwhewws")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


@juliabot(pattern="^/wssksskxxskss")
async def ramdomgamesk(event):
    if event.fwd_from:
        return
    await (await inline_query(ubot, "@gamee",
                              "Gravity"))[0].click("MissJuliaRobot",
                                                   hide_via=True)


@register(pattern="^/gravityninja$")
async def ramdomgamess(event):
    if event.fwd_from:
        return
    approved_userss = approved_users.find({})
    for ch in approved_userss:
        iid = ch["id"]
        userss = ch["user"]
    if event.is_group:
        if await is_register_admin(event.input_chat, event.message.sender_id):
            pass
        elif event.chat_id == iid and event.from_id == userss:
            pass
        else:
            return
    chat = "@MissJulia_Robot"
    async with event.client.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=1248815845))
            entity = await event.client.get_entity(OWNER_USERNAME)
            await tbot.send_message(entity, "/wssksskxxskss")
            response = await response
            await response.forward_to(event.chat_id)
        except Exception:
            pass


profanity.load_censor_words()

client = MongoClient()
client = MongoClient(MONGO_DB_URI)
db = client["spam"]
spammers = db.spammer


async def can_change_info(message):
    result = await tbot(
        functions.channels.GetParticipantRequest(
            channel=message.chat_id,
            user_id=message.sender_id,
        ))
    p = result.participant
    return isinstance(p, types.ChannelParticipantCreator) or (isinstance(
        p, types.ChannelParticipantAdmin) and p.admin_rights.change_info)


# ------ THANKS TO LONAMI ------#

# MADE BY @MissJulia_Robot


@register(pattern="^/profanity(?: |$)(.*)")
async def sticklet(event):
    if event.fwd_from:
        return
    if event.is_private:
        return
    if MONGO_DB_URI is None:
        return
    input = event.pattern_match.group(1)
    chats = spammers.find({})
    if not input:
        for c in chats:
            if event.chat_id == c["id"]:
                await event.reply(
                    "Please provide some input yes or no.\n\nCurrent setting is : **on**"
                )
                return
        await event.reply(
            "Please provide some input yes or no.\n\nCurrent setting is : **off**"
        )
        return
    if input in "on":
        if event.is_group:
            if str(event.from_id) in str(OWNER_ID):
                pass
            else:
                if not await can_change_info(message=event):
                    return

            for c in chats:
                if event.chat_id == c["id"]:
                    await event.reply(
                        "Profanity filter is already activated for this chat.")
                    return
            spammers.insert_one({"id": event.chat_id})
            await event.reply("Profanity filter turned on for this chat.")
    if input in "off":
        if event.is_group:
            if str(event.from_id) in str(OWNER_ID):
                pass
            else:
                if not await can_change_info(message=event):
                    return
            chats = spammers.find({})
            for c in chats:
                if event.chat_id == c["id"]:
                    spammers.delete_one({"id": event.chat_id})
                    await event.reply(
                        "Profanity filter turned off for this chat.")
                    return
                await event.reply(
                    "Profanity filter isn't turned on for this chat.")
    if not input == "on" or input == "off":
        await event.reply("I only understand by on or off")
        return


@register(pattern="")
async def spam_update(event):
    if not event:
        return
    if event.fwd_from:
        return
    if event.is_private:
        return
    if MONGO_DB_URI is None:
        return
    sender = await event.get_sender()
    chats = spammers.find({})
    for c in chats:
        if event.chat_id == c['id']:
            if event.is_group:
                if (await is_register_admin(event.chat_id, event.from_id)):
                    return
                else:
                    pass

            if event.text:
                msg = str(event.text)
                if profanity.contains_profanity(msg):
                    await event.delete()
                    if sender.username is None:
                        st = sender.first_name
                        hh = sender.id
                        final = f"[{st}](tg://user?id={hh}) **{msg}** is detected as a slang word and your message has been deleted"
                    else:
                        let = sender.username
                        final = f'@{let} **{msg}** is detected as a slang word and your message has been deleted'
                    dev = await event.respond(final)
                    await asyncio.sleep(10)
                    await dev.delete()
            if event.photo:
                await event.client.download_media(event.photo, "nudes.jpg")
                if nude.is_nude('./nudes.jpg'):
                    await event.delete()
                    if sender.username is None:
                        st = sender.first_name
                        hh = sender.id
                        final = f"[{st}](tg://user?id={hh}) your message has been deleted due to pornographic content"
                    else:
                        final = f'@{let} your message has been deleted due to pornographic content'
                    dev = await event.respond(final)
                    await asyncio.sleep(10)
                    await dev.delete()
                    os.remove("nudes.jpg")


@register(pattern="^/eval")
async def _(event):
    check = event.message.sender_id
    checkint = int(check)
    # print(checkint)
    if int(check) != int(OWNER_ID):
        return
    cmd = event.text.split(" ", maxsplit=1)[1]
    reply_to_id = event.message.id
    if event.reply_to_msg_id:
        reply_to_id = event.reply_to_msg_id

    old_stderr = sys.stderr
    old_stdout = sys.stdout
    redirected_output = sys.stdout = io.StringIO()
    redirected_error = sys.stderr = io.StringIO()
    stdout, stderr, exc = None, None, None

    try:
        await aexec(cmd, event)
    except Exception:
        exc = traceback.format_exc()

    stdout = redirected_output.getvalue()
    stderr = redirected_error.getvalue()
    sys.stdout = old_stdout
    sys.stderr = old_stderr

    evaluation = ""
    if exc:
        evaluation = exc
    elif stderr:
        evaluation = stderr
    elif stdout:
        evaluation = stdout
    else:
        evaluation = "Success ðŸ˜ƒ"

    final_output = "**EVAL**: `{}` \n\n **OUTPUT**: \n`{}` \n".format(
        cmd, evaluation)
    MAX_MESSAGE_SIZE_LIMIT = 4095
    if len(final_output) > MAX_MESSAGE_SIZE_LIMIT:
        with io.BytesIO(str.encode(final_output)) as out_file:
            out_file.name = "eval.text"
            await tbot.send_file(
                event.chat_id,
                out_file,
                force_document=True,
                allow_cache=False,
                caption=cmd,
                reply_to=reply_to_id,
            )

    else:
        await event.reply(final_output)


async def aexec(code, smessatatus):
    message = event = smessatatus

    def p(_x):
        return print(slitu.yaml_format(_x))

    reply = await event.get_reply_message()
    exec("async def __aexec(message, reply, client, p): " +
         "\n event = smessatatus = message" +
         "".join(f"\n {l}" for l in code.split("\n")))
    return await locals()["__aexec"](message, reply, message.client, p)


@juliabot(pattern=".eval")
async def _(event):
    check = event.message.sender_id
    checkint = int(check)
    # print(checkint)
    if int(check) != int(OWNER_ID):
        return
    cmd = event.text.split(" ", maxsplit=1)[1]
    reply_to_id = event.message.id
    if event.reply_to_msg_id:
        reply_to_id = event.reply_to_msg_id

    old_stderr = sys.stderr
    old_stdout = sys.stdout
    redirected_output = sys.stdout = io.StringIO()
    redirected_error = sys.stderr = io.StringIO()
    stdout, stderr, exc = None, None, None

    try:
        await aexec(cmd, event)
    except Exception:
        exc = traceback.format_exc()

    stdout = redirected_output.getvalue()
    stderr = redirected_error.getvalue()
    sys.stdout = old_stdout
    sys.stderr = old_stderr

    evaluation = ""
    if exc:
        evaluation = exc
    elif stderr:
        evaluation = stderr
    elif stdout:
        evaluation = stdout
    else:
        evaluation = "Success ðŸ˜ƒ"

    final_output = "**OUTPUT**:\n\n`{}`".format(evaluation)
    MAX_MESSAGE_SIZE_LIMIT = 4095
    if len(final_output) > MAX_MESSAGE_SIZE_LIMIT:
        with io.BytesIO(str.encode(final_output)) as out_file:
            out_file.name = "eval.text"
            await ubot.send_file(
                event.chat_id,
                out_file,
                force_document=True,
                allow_cache=False,
                caption=cmd,
                reply_to=reply_to_id,
            )

    else:
        await event.reply(final_output)


__help__ = """
 - /id: get the current group id. If replied to user's message gets that user's id.
 - /runs: reply a random string from an array of replies.
 - /slap: slap a user, or get slapped if not a reply.
 - /info: get information about a user.
 - /paste: Create a paste or a shortened url using del.dog
 - /getpaste: Get the content of a paste or shortened url from del.dog
 - /pastestats: Get stats of a paste or shortened url from del.dog
 - /removebotkeyboard: Got a nasty bot keyboard stuck in your group?
 - /shrug: try and check it out yourself.
 - /datetime <city>: Get the present date and time information
 - /camscanner: Reply to a image to scan and improve it's clarity.
*Instructions*
â–ªï¸The image should be a page with some written text on it (screenshots aren't permitted)
â–ªï¸The image should contain the page with four corners clearly visible
â–ªï¸The background should be somewhat darker than the page
â–ªï¸The image should contain only the page with no other objects like pencil, eraser etc. beside it(within the image)
*PRO TIP*
You can simply draw a border(a black square) around the portion you want to scan for better efficiency and edge detection
If you are still messed up send `/helpcamscanner` in pm for the tutorial !
 - /google <text>: perform a google search
 - /gps: <location> Get gps location.
 - /imdb - Get full info about a movie with imdb.com
 - /img <text>: Search Google for images and returns them\nFor greater no. of results specify lim, For eg: `/img hello lim=10`
 - /img2text <lang>: Type in reply to a image to extract the text from it
 - /img2textlang: List all the available languages
 - /phone <number in international format>: Check if the number really exists and returns information about it.If the number is fake then it will return null-type response
Example: `/phone +9162XX93X805`, `/phone +1916X978XX1`
 - /news: Returns today's Indian Headlines (ONLY WORKS IN PM)
 - /getqr: Get the QR Code content from the replied QR Code
 - /makeqr <content>: Make a QR Code from the given message (text, link, etc...)
 - /reverse: Does a reverse image search of the media which it was replied to.
 - /rmbg: Type in reply to a media to remove it's background
 - /stt: Type in reply to a voice message(english only) to extract text from it.
 - /tts <lang | text>: Returns a speech note of the text provided
 - /torrent <text>: Search for torrent links
If you are still messed up send `/helptorrent` in pm for the tutorial !
 - /wall <topic>: Searches best wallpaper on the given topic and returns them
 - /weather <city>: Get weather info in a particular place
 - /wttr <city>: Advanced weather module, usage same as /weather
 - /wttr moon: Get the current status of moon
 - /wiki <text>: Returns search from wikipedia for the input text
 - /yt <text>: perform a youtube search
 - /ytaudio <link> or /ytvideo <link>: Downlods a video or audio from a youtube video to the bots local server
 - /zip: reply to a telegram file to compressing in .zip format
 - /unzip: reply to a telegram file to decompress it from the .zip format
 - /git <username>: Returns info about a GitHub user or organization.
 - /repo <username>: Return the GitHub user or organization repository list
 - /app <appname>: Search for an app in playstore
 - /magisk: Get the latest Magisk releases
 - /device <codename>: Get info about an Android device
 - /codename <brand> <device>: Search for Android device codename
 - /specs <brand> <device>: Get device specifications info
 - /twrp <codename>: Get the latest TWRP download for an Android device
 - /song <songname artist(optional)>: uploads the song in it's best quality available
 - /lyrics <songname artist (optional)>: get the lyrics of a song
 - /barcode <text>: makes a barcode out of the text, crop the barcode if you don't want to reveal the text
 - /savefile: Gives you a permanent link of a file so that you can download it later anytime
"""

__mod_name__ = "Utilities âš¡"

ID_HANDLER = CommandHandler("id", get_id, pass_args=True)
RUNS_HANDLER = CommandHandler("runs", runs)
SHRUG_HANDLER = CommandHandler("shrug", shrug)
SLAP_HANDLER = CommandHandler("slap", slap)
INFO_HANDLER = CommandHandler("info", info, pass_args=True)
GITHUB_HANDLER = CommandHandler("git", github)
REPO_HANDLER = CommandHandler("repo", repo, pass_args=True)
ECHO_HANDLER = CommandHandler("echo", echo, filters=Filters.group)
MD_HELP_HANDLER = CommandHandler("markdownhelp",
                                 markdown_help,
                                 filters=Filters.private)
GDPR_HANDLER = CommandHandler("gdpr", gdpr, filters=Filters.private)
PASTE_HANDLER = CommandHandler("paste", paste, pass_args=True)
GET_PASTE_HANDLER = CommandHandler("getpaste",
                                   get_paste_content,
                                   pass_args=True)
PASTE_STATS_HANDLER = CommandHandler("pastestats",
                                     get_paste_stats,
                                     pass_args=True)
LYRICS_HANDLER = CommandHandler("lyrics", lyrics, pass_args=True)
STATS_HANDLER = CommandHandler("stats", stats, filters=Filters.user(OWNER_ID))
UD_HANDLER = CommandHandler("define", define)
SYNO_HANDLER = CommandHandler("synonym", synonyms)
ANTO_HANDLER = CommandHandler("antonym", antonyms)
PING_HANDLER = CommandHandler("ping", ping)

dispatcher.add_handler(PING_HANDLER)
dispatcher.add_handler(STATS_HANDLER)
dispatcher.add_handler(PASTE_HANDLER)
dispatcher.add_handler(GET_PASTE_HANDLER)
dispatcher.add_handler(PASTE_STATS_HANDLER)
dispatcher.add_handler(ID_HANDLER)
dispatcher.add_handler(RUNS_HANDLER)
dispatcher.add_handler(SLAP_HANDLER)
dispatcher.add_handler(LYRICS_HANDLER)
dispatcher.add_handler(INFO_HANDLER)
dispatcher.add_handler(ECHO_HANDLER)
dispatcher.add_handler(SHRUG_HANDLER)
dispatcher.add_handler(UD_HANDLER)
dispatcher.add_handler(MD_HELP_HANDLER)
dispatcher.add_handler(GDPR_HANDLER)
dispatcher.add_handler(GITHUB_HANDLER)
dispatcher.add_handler(REPO_HANDLER)
dispatcher.add_handler(
    CommandHandler("removebotkeyboard", reply_keyboard_remove))
dispatcher.add_handler(SYNO_HANDLER)
dispatcher.add_handler(ANTO_HANDLER)
